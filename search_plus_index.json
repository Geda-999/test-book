{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"phase01.html":{"url":"phase01.html","title":"Phase I","keywords":"","body":"HTML CSS 响应式 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"01html.html":{"url":"01html.html","title":"HTML","keywords":"","body":" 一、前端介绍 二、浏览器介绍 三、 HTML介绍 四、HTML 标签的定义 五、HTML元素的解释 六、网页的基础配置 ** 元素定义一个大标题 ```html 七、HTML 注释 八、常用标签 九、标签类型 十、类型转换 笔记 一、前端介绍 前端是什么？ 1）前端指的是网站前台部分，是运行在PC端，移动端等浏览器上展示给用户浏览的网页。 前端开发能干什么？ 制作网页(https://www.bilibili.com/) 移动端软件 PC端软件 游戏（大部分50%游戏都是前端开发去实现的） 前端开发需要掌握什么技术？ 核心技术：（HTML、CSS、 Javascript) 前端开发的就业前景 1）普遍比其他的行业薪资高。 2）初级 中级 高级 全栈 前端开发需要用什么软件？ vsCode（专业级） webstrom、hbuilder（企业级） Dreamweaver（小白入门级） 二、浏览器介绍 Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。 浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户 三、 HTML介绍 超文本标记语言（HyperText Markup Language），简称就是HTML, 是一种用于创建网页的标准标记语言. HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本内容 HTML文档也叫做 web 页面 四、HTML 标签的定义 HTML 标记标签通常被称为 HTML 标签 HTML 标签是由尖括号包围的关键词，比如 ** - HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签内容 五、HTML元素的解释 “HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思. 但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例: 这是一个段落。 六、网页的基础配置 1. **** 告诉浏览器，声明的文档类型 2. * ** 元素是 HTML 页面的根元素 3. * ** 元素包含了文档的元（meta）数据，如 ** ** 定义网页编码格式为 **utf-8** 4. * 5. * ** 元素包含了可见的页面内容 6. * ** 元素定义一个大标题 元素定义一个段落 网页标题 这是一个大标题 这是一个段落 注意：只有 里的内容才会在浏览器中显示。 七、HTML 注释 可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。 注释写法如下: 八、常用标签 1、文本标签 a、h1～h6、p、br、b、i、u、s、sub、sup 2、列表标签 ul、li、ol 3、图片标签 img 4、模块标签 div、span 5、表格标签 table 属性：border=\"1\" 边框为1。cellspacing=\"0\" 表格单元格空隙0。cellpadding=\"5\" 表格单元格内边距为5（内容离边框的距离） tr td 属性：colspan横向合并单元格、rowspan纵向合并单元格 thead tfoot 6、表单标签 账号 密码 性别 男 女 爱好 打游戏 旅游 打篮球 城市 广州 深圳 佛山 数字 留言 普通按钮 提交按钮 重置按钮 7、媒体标签 audio 音频播放 video 视屏播放 src=\"\"资源地址 controls 控制器 8、嵌套标签 标签标签（h1~h6） 网页标题 这是标题 1 这是标题 2 这是标题 3 这是标题 4 这是标题 5 这是标题 6 段落标签（p）这是一个段落。 超链接（a） 1）在href属性中指定链接的地址 这是一个链接 图片（img） 1）src属性中指定图片路径 2）通过width和height属性可以设置图片尺寸 水平线(hr) hr 元素可用于分隔内容。 这是段落。 这是段落。 文本加粗（b） 加粗文本 文本斜体（i） 加粗文本 文本的上标和下标(sup、sub) 我是 上标我是 下标 9.div 块状标签 没有任何含义，仅用于划分区域 块状标签 10.span 行内标签 没有任何含义，仅用于划分区域 行内标签 九、标签类型 块级标签，特点：独占一行，排斥其他标签。设置宽高、边距都生效。 例如：div 、p 、h1~h6、hr、ul-li 行内标签，特点：可以多个标签存在一行，不能直接设置行内标签的高度、宽度、行高以及顶和底边距，完全靠内容撑开宽高！ 例如：span、i、a、br、sub、sup 行内块标签，特点：结合的行内和块级的有点，不仅可以对宽高属性值生效，还可以多个标签存在一行显示。 例如：img、input、textarea 总结：各个标签之间的区别 1） 块标签：独自占领一行、可以进行宽高的数值的设定； ​ 2 ）行标签：在一行内显示、不可以进行宽高的数值设定； ​ 3） 行内块标签：能和其他元素待在一行，能设置宽高； 十、类型转换 三种类型之间的转换 display:inline; //转成行内元素 display:block; //转成块级元素 display:inline-block;//转成行内块级元素 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"02css.html":{"url":"02css.html","title":"CSS","keywords":"","body":" css能做什么 css如何使用 css优先级（权重） css选择器 浏览器内核 css样式 1、字体的样式 2、文本样式 3、装饰样式 4、排版布局样式 1)盒子模型 2)浮动 3)定位 4)弹性布局 5)网格布局 CSS CSS 指层叠样式表 (Cascading Style Sheets) CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一个 css能做什么 1、装饰页面。2、排版布局。 css如何使用 1、内嵌样式 内容 2、内联样式 3、外联样式 css优先级（权重） css优先级（权重） 作用范围越小，权重越高。 同样的作用范围，后面的样式覆盖前面的样式。 css选择器 //必记：id、class、元素、后代nth-child、兄弟选择、伪类、通配符 1、id选择器 例如：#a。id就像人的身份证一样，每个人都只有一个 2、class选择器 例如：.a。 class就像类别，每个人可以有多个类别 3、元素选择器 例如：div。可以选择所有的元素。 4、后代选择器 例如：.a .b。.a>.b。 可以选择.a里面的.b 指定选择第一个子元素 例如：ul li:first-child 指定选择最后一个子元素 例如：ul li:last-child 指定选择某个指定的子元素 例如：ul li:nth-child(2) 指定选择某个制定的子元素（兼容ie678） 例如：ul li:first-child+li 指定选择偶数的子元素 例如：ul li:nth-child(even).ul li:nth-child(2n+2) 指定选择奇数的子元素 例如：ul li:nth-child(odd).ul li:nth-child(2n+1) 5、兄弟选择器（相邻选择器）例如：div,p 6、伪类选择器 例如：div:hover。鼠标悬停上去div触发的效果 7、伪元素 例如ul::after 在ul的最后一个子项位置添加元素 8、通配符选择 例如：*。选中所有的元素 浏览器内核 浏览器内核 谷歌的chrome浏览器：旧 webkit 新 blink 苹果的safari浏览器：webkit 火狐的firefox浏览器：moz 欧朋浏览器： o 微软的ie浏览器： ms 微软的edge浏览器 Chromium css样式 1、字体的样式 color: red; //设置字体颜色 font-size: 60px; //字体大小 font-weight: bold; //字体加粗 font-style: italic; //字体倾斜 font-family:\"\"; //字体 //字体设置 @font-face { font-family: \"abc\"; src: url(\"abc.TTF\"); } div{ font-size: 60px; font-family:'abc';//使用字体 } 2、文本样式 text-decoration: underline; //下滑线 text-decoration: line-through; //删除线 text-align: center; //文本的水平居中 line-height:100px; //行高 display: table-cell;//转成表格元素 vertical-align: middle;//垂直居中 letter-spacing: 20px; //字间距 text-indent: 2em; //首行缩进2个字节 word-break: break-all; //所有的英文不管是否是一个单词都会换行 word-wrap: break-word; //识别到一个单词就会自动换行 overflow: hidden;//超出的部分隐藏 text-overflow: ellipsis;//超出的文本设置为省略号 //垂直居中 内容1 内容2 div{ width: 300px; height: 300px; border: 1px solid; display: table-cell; vertical-align:middle; } 3、装饰样式 width //宽度 height //高度 border: 1px solid #; //边框 （边框粗细 边框类型 边框颜色） background //背景 no-repeat 不重复 center 居中 linear-gradient(to right, red , yellow) //css3 线性渐变 (方向，初始颜色，结束颜色) background-size: 100% 100%; //背景尺寸 border-radius: 20px; //css3 圆角边框 opacity: 0.5; //css3 透明度 0～1 box-shadow: 5px 5px 5px 5px #000; //css3（x轴、y轴、阴影偏移度、阴影大小、阴影颜色） text-shadow: 2px 2px 2px #000; //css3（x轴、y轴、阴影偏移度、阴影颜色） transform //css3 变形 scale(0.5,1) //缩放（x轴，y轴） rotate(30deg) //旋转（角度） skew(30deg,30deg)//倾斜角度 translate(200px,200px) //平移 4、排版布局样式 1)盒子模型 margin 外边距 padding 内边距 边距塌陷：块级元素的上下外边距会出现边距塌陷。 解决方法：在父级元素添加 overflow:hidden; 2)浮动 浮动：浮动元素可以理解为浮起来的木板，非浮动元素可以立即为水流 浮动元素属于非正常文档流 浮动元素拥有把所有 元素变成了行内块级的特性 浮动塌陷:当一个元素里面只有浮动的元素，那么就会出现浮动塌陷 清除浮动 兼容所有浏览器的清除浮动写法 .clearFix::after{ content: \"\";/*内容为空*/ visibility: hidden;/*隐藏*/ height: 0;/*高度为0*/ display: block;/*转位块级元素*/ clear: both;/*清除浮动*/ } 3)定位 相对定位 position: relative; 相对于自己定位。 绝对定位 position: absolute; 相对于有相对定位的父级元素进行定位，没有的时候就相对于body。 固定定位 position: fixed; 相对于浏览器定位。 4)弹性布局 css3样式 //父级元素样式 display: flex; //弹性布局 flex-direction //设置主轴的方向 row //主轴为水平方向，起点在左端。 row-reverse //主轴为水平方向，起点在右端。 column //主轴为垂直方向，起点在上沿。 column-reverse //主轴为垂直方向，起点在下沿。 flex-wrap //设置是否换行 wrap //换行 justify-content //主轴的对齐方式 center //居中 space-between //两端对齐 space-around //每个元素两侧的间隔相等 space-evenly //每个间隔都相等 align-items //交叉轴对齐方式 center //居中 align-content //多行对齐方式 center //居中 //子级元素样式 order //属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow //属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 //如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 flex-shrink //属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 //如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 //负值对该属性无效。 flex-basis //属性定义了在分配多余空间之前，项目占据的主轴空间 //效果跟宽度一样 flex //flex-grow, flex-shrink 和 flex-basis的简写 //1 1 auto,0 0 auto //建议用这个 align-self //单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 5)网格布局 //父元素 display:grid; grid-template-columns:repeat(3,1fr);//定义每一列的列宽 1fr代表1个片段，总宽占的比例 repeat是重复 grid-template-rows: repeat(3,1fr);//定义每一行的行宽 //子元素 grid-column-start: 1;//控制单元格的从哪里开始 grid-column-end: 3;//控制单元格的从哪里结束 grid-row-start: 1; grid-row-end: 3; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"03响应式.html":{"url":"03响应式.html","title":"响应式","keywords":"","body":" 一、响应式布局介绍 二、常见手机屏幕尺寸 三、响应式框架 四、bootstrap介绍 响应式 一、响应式布局介绍 响应式布局是什么？ 实现不同屏幕分辨率的终端上浏览网页的不同展示方式。 常见布局方式 1）流式布局（响应式布局） 1.1）pc和移动端共用一套页面； 1.2）优点：只需要写一套代码，就能在多端运行 1.3）缺点：维护困难 1.4）适合创业或者建站公司 2）rem布局（自适应布局） 2.1）H5页面（比如：微信页面）、移动端 2.2）优点：维护容易 2.3）缺点：需要额外写其他端的代码 2.4）适合开发自己公司的网站 响应式布局怎么实现？ 1）设置meta标签 viewport 视图width=device-width 可视区域的宽度为设备的宽度， 如果不设置的话，默认视口宽度为980pxinital-scale=1 页面首次被显示的可视区域的缩放级别，取值1.0则页面按实际尺寸显示， 无任何缩放maximum-scale=1 用户可将页面放大的程序。 1.0将禁止用户放大到实际尺寸之上user-scalable=no 禁止用户缩放操作 2）媒体查询 2.1）概念：根据条件告诉浏览器如何为指定视图宽度渲染页面 2.2）设置单个视图宽度 @media screen and (max-width: 980px) { div { 样式属性 }} 2.3）设置多个视图宽度 /** iPad **/ @media only screen and (min-width: 768px) and (max-width: 1024px) {} @media only screen and (min-width: 320px) and (max-width: 767px) {} 2.4) 设置link标签 注意事项 3.1）宽度需要使用百分比 #head { width: 100% }#content { width: 50%; } 3.2）其余的样式，如字体，高度，margin，padding等都按照设计稿标注尺寸的一半来设置 3.3）物理像素和设计稿像素比例是1：2 3.4）对于有些屏幕尺寸下，我们设置的固定值看起来不是特别好看的话，使用@media进行微调 3.5）处理图片缩放，给图片指定的最大宽度为百分比。假如图片超过了，则自动缩小调整。假如图片小了，则原尺寸输出 img { width: auto; max-width: 100%; } 二、常见手机屏幕尺寸 苹果手机（ios） 1）5s以下都是320px宽度、6是375px宽度、6plus是414px宽度 安卓手机（android） 1）320、360、480、540、640、720 设计稿 1）640×1136 、640*×960 、750×1334 三、响应式框架 bootstrap iview 1）一套微信小程序的ui组件库 elements lay-ui 四、bootstrap介绍 bootstrap是什么？ 1）bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。 主要用于做响应式开发、移动端开发 安装 1）下载压缩包 2）通过cdn下载css、js、jq（https://blog.csdn.net/qq_35077107/article/details/105588524） 2.1) CDN就是内容传递网络，Content Delivery Network的缩写就是 CDN，简单的说就是Bootstrap把自己的css、Js等文件托管到某一个网络服务器上使用时调用。如果与Internet不通则无法使用CDN加速，可将文件下载到本地引用 如何使用？ 1）引入基本样式、js、jq 1.1）bootstrap的所有js效果都依赖jq，所以必须要加载jq 2）在标题上添加meta标签 或者 布局容器 1）.container : 用于固定宽度并支持响应式布局的容器 .container-fluid : 用于100%宽度，占据全部视口（viewport）的容器 3）bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。 注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。 栅格系统 1）随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列 1 2 3 4 5 6 7 8 9 10 11 12 类前缀 1）.col-xs- 1.1) 超小屏幕、手机、 2）.col-sm- 2.1) 小屏幕 、平板、≥768px 3）.col-md- 3.1) 中等屏幕、桌面显示器、≥992px 4）.col-lg- 4.1) 大屏幕、大桌面显示器、≥1200px 全局css样式 概念：直接添加标签或者class即可生效使用 2）辅助类 2.1）快速浮动 pull-left(左浮动)pull-right(右浮动) 注意：不能用于导航条组件中 导航条应该用.navbar-left 或 .navbar-right 2.2) 让内容块居中 .center-block(居中) 2.3）清除浮动 .clearfix(加在父元素上可清除浮动) 2.4）显示或隐藏内容 ```css .show(显示内容).hidden(隐藏内容) ``` 组件 1）字体图标 1.1）添加一个空的span标签，并加上class，不要与其他class混用 2）导航栏(.nav) 2.1）外层必须为nav标签 tokyoHot 首页 新闻中心 详情页 3）data-toggle 3.1）用于告诉 JavaScript 需要对按钮做什么 4）data-target 4.1）指示要切换到哪一个元素 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"phase02.html":{"url":"phase02.html","title":"Phase II","keywords":"","body":" npm webpack typescript git scss JavaScript npm webpack typescript git scss Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"JavaScriptES5.html":{"url":"JavaScriptES5.html","title":"JavaScriptES5","keywords":"","body":"JavaScriptES5 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"01变量.html":{"url":"01变量.html","title":"01变量","keywords":"","body":" 一、创建变量 二、var声明变量带来的问题 1、变量提升 2、给window添加属性 3、可以重复声明 变量 一、创建变量 es5 var a = 1 console.log(a);//1 es6 let a = 1 console.log(a);//1 二、var声明变量带来的问题 1、变量提升 使用var声明变量，会让该变量提升到当前作用域的最顶部，等价于以下代码 console.log(a)//undefined var a = 1 var a console.log(a)//undefined var a = 1 2、给window添加属性 声明全局变量的时候相当于给window对象也添加了一个属性 es5 var a = 1 console.log(a)//1 console.log(window.a)//1 es6 let a = 1 console.log(a)//1 console.log(window.a)//undefined 3、可以重复声明 连续声明变量不会报错，而是重新赋值 es5 var a = 1 var a = 2 console.log(a)//2 es6 【es6这种就报错了】 let a = 1 let a = 2 console.log(a);//报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"02常量.html":{"url":"02常量.html","title":"02常量","keywords":"","body":"常量 不能再进行更改的量，一般用于做一些不再更改的量，比如 baseUrl 等 const a = 1 const a = 2//报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"03js数据类型.html":{"url":"03js数据类型.html","title":"03js数据类型","keywords":"","body":"一、检测数据类型 type of 变量 二、js数据类型 数字 number 字符串 string 布尔值 boolean 空值 null 未定义 undefined 对象 object 唯一值 symbol Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"05数字类型.html":{"url":"05数字类型.html","title":"05数字类型","keywords":"","body":" 1、定义数字类型 2、隐式运算 3、非数字类型 数字类型 1、定义数字类型 在js中没有浮点型和整型之分,通通都是数字类型 var num = 1 console.log(typeof num); //number 2、隐式运算 var a = 1 var b = 2 console.log(a + b);//3 字符串 +号在有字符串 的时候会实现字符串拼接功能 var a = \"1\" var b = 2 console.log(a + b);//12 数字 -号会把字符串类型 转为数字类型 var a = \"1\" var b = 2 console.log(a - b);//-1 数字类型（非数字）强转但是转不了数字 所以变为非数字类型 var a = \"中\" var b = 2 console.log(a - b);//NaN 3、非数字类型 属于数字类型的一种特殊存在 非数字类型 属于数字类型 var a = \"中\" var b = 2 var c = a + b console.log(typeof c);//string var a = \"中\" var b = 2 var c = a - b console.log(typeof c);//number 检测非数字类型 使用isNaN可以检测 出这个值是否属于非数字 var a = \"中\" var b = 2 var c = a + b console.log(isNaN(c));//true Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"06字符串.html":{"url":"06字符串.html","title":"06字符串","keywords":"","body":" 1、声明字符串 2、字符串拼接 3、字符串长度属性 4、字符串操作 1. 字符串截取 2. 字符串转数字 3. 字符串转数组 4. 字符串替换 5. 查找字符串位置 6. 字符串拼接 7. 字符串转大小写 字符串 1、声明字符串 在js中单双引号 没有区别,以下没有区别 var a = \"hello world\" var b = 'hello world' 2、字符串拼接 es5 var a = \"娜美\" var b = \"有宙斯\" console.log(a + b); //娜美有宙斯 es6 除了字符串拼接还可以实现换行 let a = \"娜美\" let b = \"有宙斯\" console.log(`${a}${b}`); //娜美有宙斯 3、字符串长度属性 // 1 2 3 4 5 6 7 8 9 10 var a = \"娜美,妮可罗宾,大和\" console.log(a.length);//10 4、字符串操作 1) 字符串截取 slice()、substring()、substr() slice(start,end) start是必填参数，代表第一个字符串所在的位置， ​ end可选，代表最后一个字符串之前， end可以是负数 //截取妮可罗宾 var a = \"娜美，妮可罗宾，大和\" console.log(a.slice(3, 7));//妮可罗宾 //截取妮可罗宾,大和 var a = \"娜美，妮可罗宾，大和\" console.log(a.slice(3, a.length));//妮可罗宾，大和 substring(start,end) 用法跟slice一样，唯一不同是end不能使用负数 var str = '娜美，妮可罗宾，大和'; console.log(str.substring(3)); //妮可罗宾，大和 //第3位后面的数字全都显示 substr(start,length) 第二个参数为截取长度，不能为负数 var str = '娜美，妮可罗宾，大和'; console.log(str.substr(3, 4)); //妮可罗宾 //3是从，后面开始就不要了 4是从，3的前面开始的第四位都要。 2) 字符串转数字 Number 或 -0 var a = \"5\" console.log(Number(a));//5 var b = \"5\" console.log(b - 0);//5 var c = \"娜美\" console.log(c - 0);//NaN 文字或英文字母就返回NaN 3) 字符串转数组 split() console.log(a.split(\"\"));//[\"h\", \"e\", \"l\", \"l\", \"o\"] var b = \"hello,world\" console.log(b.split(\",\"));//[\"hello\", \"world\"] var c = \"hello world\" console.log(c.split(\" \"));//[\"hello\", \"world\"] 4) 字符串替换 replace() var a = \"娜美，妮可罗宾，大和\" console.log(a.replace(\"娜美\", \"波雅汉考克\"));//波雅汉考克，妮可罗宾，大和 也可以使用正则进行替换 g:所有，i:单个 var a = \"波雅汉考克，妮可罗宾，大和\" console.log(a.replace(/波雅汉考克/g, \"女帝\"));//女帝，妮可罗宾，大和 5) 查找字符串位置 前：indexOf() 后：lastIndexOf() // 0 1 2 3 4 5 6 7 8 9 10 var a = \"这是哪里，在这里，哪里\" console.log(a.indexOf(\"里\"));//3 console.log(a.lastIndexOf(\"里\"));//10 lastIndexOf这个直接到后了 案例：打印所有【里】的位置 var a = \"这是哪里，在这里，哪里\" var arr = a.split(\"\") arr.forEach(function (item, dd) { if (item === \"里\") { console.log(dd);//3, 7, 10 } }) 6) 字符串拼接 es5💖 var a = \"娜美\" var b = \"有宙斯\" console.log(a + b); //娜美有宙斯 es6，反引号 var a = \"娜美\" var b = \"有宙斯\" console.log(a.concat(b));//娜美有宙斯 7) 字符串转大小写 转大写 var a = \"hello\" console.log(a.toUpperCase());//HELLO 转小写 var b = \"WORLD\" console.log(b.toLowerCase());//world Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"07布尔值.html":{"url":"07布尔值.html","title":"07布尔值","keywords":"","body":" 在js里面1可以代表true，0 代表false //第一种 let a = true if(a == 1){ console.log(\"a是true\")//true }else{ console.log(\"a是false\") } //第二种 let a = true if(a == 2){ console.log(\"a是true\") }else{ console.log(\"a是false\")//false } //第三种 let a = false if(a == 1){ console.log(\"a是true\") }else{ console.log(\"a是false\")//false } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"08空值.html":{"url":"08空值.html","title":"08空值","keywords":"","body":" let a = null; console.log(a);//null let a = null; console.log(typeof a);//打印出来object，因为js的历史原因，没有修复 //可以使用!来判断空值 let a = null; if(!a){ console.log(\"a是空值\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"09未定义.html":{"url":"09未定义.html","title":"09未定义","keywords":"","body":" //没有赋值 let a; console.log(a)//undefined ////可以使用!来判断未定义 let a; if(!a){ console.log(\"a是未定义\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"10唯一值.html":{"url":"10唯一值.html","title":"10唯一值","keywords":"","body":" symbol可以用来做对象的key值 但是正常情况下无法获取symbol 需要特殊方法才可以 使用symbol.for来存储数据 //每次创造出来的symbol都是唯一的，所以称为唯一值 let syb1 = Symbol(\"描述1\") let syb2 = Symbol(\"描述2\") console.log(syb1) console.log(syb2) console.log(syb1 === syb2)//false symbol可以用来做对象的key值 let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; 但是正常情况下无法获取symbol let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; for(key in obj){ console.log(key)//没有symbol } 需要特殊方法才可以 let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; console.log(Object.getOwnPropertySymbols(obj))//打印出当前对象的所有symbol属性 console.log(Reflect.ownKeys(obj))//打印当前对象所有的属性，包括symbol 使用symbol.for来存储数据 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"11对象.html":{"url":"11对象.html","title":"11对象","keywords":"","body":" 1、创建对象 获取值（value） 2、迭代对象的key和value es5写法 es6写法✨ 3、对象的增删改查操作 4、在对象里面的this关键字 1、方法 2、方法 5、对象的分类 对象 1、创建对象 字面量创建法 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } 获取值（value） var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } console.log(obj.name); //娜美✨✨ // console.log(obj[\"name\"]);//娜美 //也可以这样的写法 对象的value值可以写任意的值，而key只能写字符串 注意，对象没有length属性 2、迭代对象的key和value es5写法 只能迭代对象的value值 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } for (key in obj) { console.log(obj[key]) //娜美，18 console.log(key);//name、age } 案例：对象转【数组】 var obj = { name: \"娜美\", age: 18, sex: \"女\" }; var arr = [] for (key in obj) { arr.push(obj[key]) //arr.unshift()这种是反着来了 } console.log(arr);//[\"娜美\", 18, \"女\"] es6写法✨ 转【数组】 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } console.log(Object.keys(obj)) //key [\"name\", \"age\"] console.log(Object.values(obj))//value [\"娜美\", 18] 3、对象的增删改查操作 增 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } obj.sex = \"女\" // obj[\"sex\"] = \"男\" //也这可以这样的写法 console.log(obj);//{name: \"娜美\", age: 18, sex: \"女\"} 删 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sex: \"女\" } delete obj.sex console.log(obj);//{name: \"娜美\", age: 18} 改 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } // obj[\"name\"] = \"大和\" //也这可以这样的写法 obj.name = \"妮可罗宾\" console.log(obj); //{name: \"妮可罗宾\", age: 18} 查 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sex: \"女\" } // console.log(obj[\"name\"]); //也这可以这样的写法 console.log(obj.name); //娜美 console.log(Object.keys(obj));//[\"name\", \"age\", \"sex\"] console.log(Object.values(obj));//[\"娜美\", 18, \"女\"] 4、在对象里面的this关键字 关键字\"this\"指向了当前所在的上下文对象 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sayHello: function () { console.log(this);//obj对象 {name: \"娜美\", age: 18, sayHello: ƒ} console.log(this.name);//娜美 } } obj.sayHello() this 是对象的指针，指的当前上下文手指的对象 隔壁老王的儿子，不是他儿子 隔壁刘王的儿子，不是他儿子 1、方法 var obj = { name: \"阿丽塔\", age: 18, sex: \"女\", say: function () { console.log(this);//{name: \"阿丽塔\", age: 18, sex: \"女\", say: ƒ} }, }; obj.say(); 这种是特殊了 console.log(this);//window 2、方法 var obj = { name: \"娜美\", obj2: { name: \"妮可罗宾\", say: function () { console.log(this); //{name: \"妮可罗宾\", say: ƒ} } } } obj.obj2.say() // obj[\"obj2\"].say() //也可以这样子写 5、对象的分类 //宿主对象（根据js所处的环境的对象） dom(document object model 文档对象模型) bom(browser objcet model 浏览器对象模型) //本地对象（需要实例化的，js自带的对象） new Object() new Function() new Array() new String() new Boolean() new Number() new Date() new RegExp() new Error() //内置对象(不需要实例化的对象) Global Math Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"12内置全局对象.html":{"url":"12内置全局对象.html","title":"12内置全局对象","keywords":"","body":" 1、数学对象 圆周率 四舍五入 绝对值 向上取整 向下取整 幂 平方根 正弦 余弦 最小值 最大值 随机数 案例 2、全局对象 内置对象、全局对象 1、数学对象 圆周率 Math.PI 四舍五入 Math.round() console.log(Math.round(189.09));//189 console.log(Math.round(189.0001));//189 console.log(Math.round(175.0001));//175 console.log(Math.round(173.642));//174 绝对值 Math.abs() console.log(Math.abs(189.09));//189.09 console.log(Math.abs(189.0001));//189.0001 console.log(Math.abs(175.0001));//175.0001 console.log(Math.abs(173.642));//173.642 向上取整 Math.ceil() console.log(Math.ceil(189.09));//190 console.log(Math.ceil(189.0001));//190 console.log(Math.ceil(175.0001));//176 console.log(Math.ceil(173.542));//174 向下取整 Math.floor() console.log(Math.floor(189.09));//189 console.log(Math.floor(189.0001));//189 console.log(Math.floor(175.0001));//175 console.log(Math.floor(173.642));//173 幂 Math.pow() 平方根 Math.sqrt() 正弦 Math.sin() 余弦 Math.cos() 最小值 Math.min() console.log(Math.min(1, 2, 3));//1 console.log(Math.min(-1, -2, -3));//-3 var arr = [1, 2, 3] console.log(Math.min(...arr));//1 最大值 Math.max() console.log(Math.max(1, 2, 3));//3 console.log(Math.max(-1, -2, -3));//-1 var arr = [1, 2, 3] console.log(Math.max(...arr));//3 随机数 Math.random() console.log(Math.random());//0.5701630074981394 console.log(Math.round(Math.random()));// 0 , 1 console.log(Math.ceil(Math.random()));// 1 console.log(Math.floor(Math.random()));// 0 console.log(Math.abs(Math.random()));// 0.5701630074981394 案例 公式：Math.random() * （max - min）+ min // 2、请显示1-6之间的随机数 console.log(Math.ceil(Math.random() * 6)); // 案例：生成一个n到m之间的随机整数 function getRandom(n, m) { var choise = m - n + 1 //随机整数的个数 return Math.floor(Math.random() * choise + n) } var random1 = getRandom(2, 6) console.log(random1); 2、全局对象 encodeURI()//把字符串编码为 URI统一资源标识符 decodeURI()//解码某个编码的 URI isNaN()//检查某个值是否是数字 Number()//把对象的值转换为数字 parseFloat()//解析一个字符串并返回一个浮点数 parseInt()//解析一个字符串并返回一个整数 String()//把对象的值转换为字符串 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"13数组.html":{"url":"13数组.html","title":"13数组","keywords":"","body":" 1、创建数组 2、数组属性 3、数组的增删改查 4、判断是否为数组 5、遍历数组 1. 遍历简洁数组 for for in✨ forEach✨ map✨ 2. 遍历复杂数组 6、数组的方法 1. 数组的变异方法 最后一个pop、push✨ 第一个unshift、shift✨ 万能✨💖 反转数组 数组排序 2. 数组的非变异方法 1数组每个元素相乘 2用forEach数组每个元素相乘 3数组之间的合并 4数组元素中所在的位置 5数组转字符串 6挑选数组元素并转新数组 7选择元素其余过滤掉 7、数组的操作✨💖 1、数组去重☃🏃‍♀️ 方法1 方法2 方法3(es6)✨ 2、数组的交并补差 合并 交集 并集 补集 差集 数组 1、创建数组 //第一种 ✨ 0 1 2 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\"] //第二种 var arr2 = new Array(\"娜美\", \"妮可罗宾\", \"大和\") console.log(arr2);//[\"娜美\", \"妮可罗宾\", \"大和\"] 2、数组属性 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr.length);//3 获取第一个成员 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr[0]);//娜美 获取最后一个成员 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr[arr.length - 1]);//大和 3、数组的增删改查 增 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr[3] = \"波雅汉考克\" console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 删 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] delete arr[0] console.log(arr);//[empty, \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 改 var arr = [\"empty\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr[0] = \"娜美\" console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 查 // 0 1 2 3 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] console.log(arr[2]);//大和 4、判断是否为数组 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(Array.isArray(arr));//true ✨✨ console.log(arr instanceof Array);//true console.log(Object.prototype.toString.call(arr));//[object Array] 5、遍历数组 1) 遍历简洁数组 for var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] for (var i = 0; i for in✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] for (i in arr) { console.log(arr[i]);//娜美，妮可罗宾，大和 } forEach✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.forEach(function (item) { console.log(item);//娜美，妮可罗宾，大和 }) // // 也可以这样写 // arr.forEach((item) => { // console.log(item); // }) map✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.map(function (item) { console.log(item);//娜美，妮可罗宾，大和 }) 2) 遍历复杂数组 var arr = [ { countryName: \"中国\", cites: [ { cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"汕尾\" }, ], }, { countryName: \"美国\", cites: [ { cityName: \"华盛顿\" }, { cityName: \"纽约\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cites: [ { cityName: \"东京\" }, { cityName: \"北海道\" }, { cityName: \"大阪\" }, ], }, ]; arr.map(function (item) { item.cites.map(function (items) { console.log(items.cityName) }) }) 6、数组的方法 1) 数组的变异方法 最后一个pop、push✨ 删除最后一个成员【pop】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.pop() console.log(arr);//[\"娜美\", \"妮可罗宾\"] 添加最后一个成员【push】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.push(\"波雅汉考克\") console.log(arr);// [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 第一个unshift、shift✨ 删除第一个成员【shift】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.shift() console.log(arr);//[\"妮可罗宾\", \"大和\", \"波雅汉考克\"] 添加第一个成员【unshift】 var arr = [\"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.unshift(\"娜美\") console.log(arr);// [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 万能✨💖 splice var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.splice(0, 0, \"new\") //01:位置，02:删除几个，03:增加 console.log(arr);//[\"new\", \"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 反转数组 就是最后的数字就被排到前面来 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.reverse() console.log(arr);//[\"波雅汉考克\", \"大和\", \"妮可罗宾\", \"娜美\"] 数组排序 就是一些扰乱的数字就可以排成整整齐齐 var arr = [3, 1, 0, 2] arr.sort() console.log(arr);//[0, 1, 2, 3] 2) 数组的非变异方法 1数组每个元素相乘 通过指定函数处理数组的每个元素，并返回处理后的数组 var arr = [1, 2, 3, 4] var arr2 = arr.map(function (item) { return item * 2 }) console.log(arr2);//[2, 4, 6, 8] 2用forEach数组每个元素相乘 forEach 为每个数组元素调用一次函数 只能迭代数组不能修改数组的成员 var arr = [1, 2, 3, 4] var arr2 = [] arr.forEach(function (item) { arr2.push(item * 2) }) console.log(arr2);// [2, 4, 6, 8] 3数组之间的合并 连接两个或更多的数组合并，并返回结果 var arr = [1, 2, 3] var arr2 = [4, 5, 6] var arr3 = arr.concat(arr2) console.log(arr3);// [1, 2, 3, 4, 5, 6] 4数组元素中所在的位置 搜索数组中的元素，并返回它所在的位置 // 0 1 2 var arr = [1, 2, 3] console.log(arr.indexOf(1));//0 console.log(arr.indexOf(4));//-1 没有出现在arr元素中就返回-1 5数组转字符串 把数组的所有元素放入一个字符串 var arr = [\"波雅汉考克\", \"大和\", \"妮可罗宾\", \"娜美\"] console.log(arr.join());//波雅汉考克,大和,妮可罗宾,娜美 6挑选数组元素并转新数组 选取数组的的一部分，并返回一个新数组 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] var arr2 = arr.slice(0, 2) console.log(arr2);//[\"娜美\", \"妮可罗宾\"] 7选择元素其余过滤掉 过滤 数组，返回过滤后的数组 var arr = [1, 2, 3] var newArr = arr.filter(function (item) { return item % 2 === 0 }) console.log(newArr);//[2] 判断数组里面所有值 都符合条件，才返回true var arr = [1, 2, 3, -1, 3, 6] var bool = arr.every(function (item) { return item > 0 }) console.log(bool);//false 判断数组里面其中一个值 符合条件，就返回true var arr = [1, 2, 3, -1, 3, 6] var bool = arr.some(function (item) { return item > 0 }) console.log(bool);//true 7、数组的操作✨💖 1、数组去重☃🏃‍♀️ 方法1 var arr = [2, 2, 1, 6, 5]; var arr2 = []; arr.forEach(function (item) { if (arr2.indexOf(item) === -1) { arr2.push(item); } }); console.log(arr2);//[2, 1, 6, 5] 方法2 var arr = [2, 2, 1, 6, 5]; var arr2 = []; for (var i = 0; i 方法3(es6)✨ var arr = [2, 2, 1, 6, 5]; console.log([...new Set(arr)]);//[2, 1, 6, 5] 2、数组的交并补差 合并 合-两组合并，全有数都要 var arr = [1, 2, 3]; var arr2 = [4, 5, 6]; console.log(arr.concat(arr2)); //[1, 2, 3, 4, 5, 6] 交集 交集-两组合并相同就保留 数组交集(两个数组都有的值) var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 4, 6]; var arr3 = []; arr.forEach(function (item) { arr2.forEach(function (item2) { if (item === item2) { arr3.push(item); } }); }); console.log(arr3);//[2, 4] 并集 并集-两组合并有相同就保留一个数 数组并集(两个数组合并在一起不重复的值) var arr = [2, 4, 6, 8, 10]; var arr2 = [1, 2, 3, 4, 5]; var arr3 = arr.concat(arr2); console.log([...new Set(arr3)]);// [2, 4, 6, 8, 10, 1, 3, 5] grol 补集 补-两组合并有相同就舍掉 数组补集(两个数组不重复的值合并一起) var arr = [1, 2, 3, 4]; var arr2 = [1, 3, 5]; var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }); var newArr2 = arr2.filter(function (item) { return arr.indexOf(item) === -1; }); console.log(newArr.concat(newArr2)); //[2, 4, 5] 差集 差-两组对比最终要第一组 有跟第二组相同舍掉 数组差集(a数组有 b数组没有的) var arr = [1, 2, 3, 4, 5] var arr2 = [2, 4, 6, 8] var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }) console.log(newArr);//[1, 3, 5] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"14函数.html":{"url":"14函数.html","title":"14函数","keywords":"","body":" 函数 函数的创建方式 1、一个叫fn的函数 2、一个函数然后赋值给fn 3、一个匿名函数 4、一个匿名函数 函数的属性 属性 属性转数组 关键字 函数复用性 作用域 1、没有声明就是上面的a 2、声明之后跟上面的a没有关系 闭包特性 加强记忆、 函数 函数的创建方式 长方形的面积 = 长 * 宽 //形式参数 50 = 10 * 5 //实际参数 function fn(形参){执行的内容} 1、一个叫fn的函数 function fn(a, b) { console.log(a * b); } fn(10, 5) //50=10*5 2、一个函数然后赋值给fn var fn = function (a, b) { console.log(a * b); } fn(10, 5) //50=10*5 3、一个匿名函数 (function (a, b) { console.log(a * b); })(10, 5) //50=10*5 4、一个匿名函数 !function (a, b) { console.log(a * b); }(10, 5) //50=10*5 函数的属性 属性 function fn() { console.log(arguments); } fn(1, 2, 3, 4, 5)//[1, 2, 3, 4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] 属性转数组 function fn() { console.log([...arguments]); } fn(1, 2, 3, 4, 5)//[1, 2, 3, 4, 5] 关键字 function fn(a, b) { console.log(this)//当前所在的作用域对象window return//返回值 } fn(1, 2) // {window: Window, self: Window, document: document, name: \"\", location: Location, …} function fn(a, b) { return a * b } console.log(fn(10, 5)); //50=10*5 函数复用性 function fn(a, b) { return a * b } fn(10, 5) fn(20, 10) 作用域 局部作用域可以访问全局作用域 但是全局作用域正常情况下访问不了局部作用域 例如：你在外面想看别人家洗澡是看不到了。哪里面的人就可以看的了外咯 var a = 1//在函数外声明的变量称为全局作用域 function fn(){ var a = 2//在函数里面声明的变量称为局部作用域 } var a = 1//全局变量 function fn() { console.log(a);//可以打印 } fn() function fn() { var a = 1//局部变量 } fn() console.log(a);//不可以打印 // 总结：函数里面可以访问函数外面，但是反过来不行 1、没有声明就是上面的a var a = 1 function fn1() { a = 2 //没有声明就是上面的a } fn1() console.log(a);//2 2、声明之后跟上面的a没有关系 var a = 1 function fn1() { var a = 2//声明之后跟上面的a没有关系 } fn1() console.log(a);//1 var a = 1 function fn1() { console.log(a);//undefined var a = 2 console.log(a);//2 } fn1() console.log(a);//1 闭包特性 函数闭包 闭包可以访问其他函数的作用域的数据，这个函数就被称为闭包 闭包实际上并没有让变量累加，累加靠的是垃圾回收机机制没有回收变量数据 闭包有什么用 1、获取局部变量的值 2、避免全局变量污染 3、用来做类的私有属性 function fn() { var a = 1; return function fn2() { //这个是闭包 console.log(++a); }; } var afn = fn(); afn(); //2 afn(); //3 加强记忆、 function fn() { var a = 1 return function fn2() {//这个是闭包 var b = 1 return function fn3() {//这个是闭包 console.log(++b); } } } var afn = fn()() //实际这里就多加的括号 afn()//2 afn()//3 //闭包 //闭包在使用的时候，能暂时性的存储数据到内存里面，如果是低版本浏览器（ie5-ie7） //就会出现内存泄漏问题，导致越来越卡，而新版本的浏览器比如chrome就不会有这种问题 function fn(){ let a = 1 function fn2(){ return ++a } return fn2 } let f = fn() console.log(f())//2 console.log(f())//3 console.log(f())//4 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"15日期对象.html":{"url":"15日期对象.html","title":"15日期对象","keywords":"","body":" 获取日期对象 获取年月日星期时分秒 更改时间 格式化日期 字串转原型 获取时间戳 定时器 计时器 获取B站的所有标签符 日期对象 获取日期对象 new Date() 获取年月日星期时分秒 var week = [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"]//日期数组 var time = new Date()//获取日期对象 var year = time.getFullYear()//获取年 var month = time.getMonth() + 1//获取月 var date = time.getDate()//获取日 var day = time.getDay()//获取星期 var hours = time.getHours()//获取时 var minutes = time.getMinutes()//获取分 var seconds = time.getSeconds()//获取秒 console.log(year + \"年\" + month + \"月\" + date + \"日\" + \"星期\" + week[day] + hours + \"时\" + minutes + \"分\" + seconds + \"秒\"); //2021年12月15日星期三14时53分53秒 更改时间 var time = new Date(1999, 0, 1); console.log(time); 格式化日期 var time = new Date(2021, 0, 1) function formDate(formObject, sign = \"-\") { var year = formObject.getFullYear() var month = formObject.getMonth() + 1 var date = formObject.getDate() function formTime(number) { var str = String(number)//转成字符串 return str.length >= 2 ? str : \"0\" + str //三元运算符，如果字符串长度大于等于2，就返回str变量，如果不是就返回拼接的字符 } console.log(year + sign + formTime(month) + sign + formTime(date));//2021-01-01 } formDate(time) 字串转原型 var str = \"2021-12-15\"; function formDate(str, sign = \"-\") { var arr = str.split(sign); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year, month, date)); } formDate(str); //Wed Dec 15 2021 00:00:00 GMT+0800 (中国标准时间) 获取时间戳 var t = new Date() console.log(t.getTime());//时间戳是1970年1月1日0时0分0秒到现在的毫秒 定时器 var time1 = new Date(); var t1 = time1.getTime(); var time2 = new Date(2022, 0, 1); var t2 = time2.getTime(); var t = Math.floor(Math.abs(t1 - t2) / 1000); //现在距离2020还有多少秒 var date = Math.floor(t / (60 * 60 * 24)); //日 var modul = t % (60 * 60 * 24); //求余(用距离2020剩下的秒来求余天，剩下的就是时) var h = Math.floor(modul / (60 * 60)); //时 modul = t % (60 * 60); var m = Math.floor(modul / 60); //分 modul = t % 60; var s = Math.floor(modul); //秒 console.log(date + \"日\" + h + \"时\" + m + \"分\" + s + \"秒\"); 计时器 setInterval(function () { var time1 = new Date(); var t1 = time1.getTime(); var time2 = new Date(2021, 12, 12); var t2 = time2.getTime(); var t = Math.floor(Math.abs(t1 - t2) / 1000); //现在距离2020还有多少秒 var date = Math.floor(t / (60 * 60 * 24)); //日 var modul = t % (60 * 60 * 24); //求余(用距离2020剩下的秒来求余天，剩下的就是时) var h = Math.floor(modul / (60 * 60)); //时 modul = t % (60 * 60); var m = Math.floor(modul / 60); //分 modul = t % 60; var s = Math.floor(modul); //秒 var body = document.querySelector(\"body\"); body.innerHTML = date + \"日\" + h + \"时\" + m + \"分\" + s + \"秒\"; }, 1000); 获取B站的所有标签符 //第一种 console.log( [ ...new Set( [...document.querySelectorAll(\"*\")].map((item) => item.nodeName) ), ].length ); //第二种 console.log(new Set($$(\"*\").map(e => e.tagName))); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"16正则表达式.html":{"url":"16正则表达式.html","title":"16正则表达式","keywords":"","body":" 一、正则表达式字符匹配 创建正则表达式 正则表达式方法 1)test （正则方法）🏳‍🌈 在hello外面new一个数 在hello里面new一个数 2. search （字符串方法） 3. match(字符串方法) 4. exec(正则方法) 🏳‍🌈 5. replace（字符串方法） 案例 修饰符 1. 加的【i】 2 )加的【g】🐱‍👤 3. 加的【m】 纵向模糊匹配🚓 1、字符组 1. 范围表示 2. 排除字符组 3. 字符组简写 大法中🐱‍👤💨 横向模糊匹配 1、量词 案例 2、贪婪匹配和惰性匹配 多选分支 案例 二、正则表达式位置匹配 位置 位置匹配 1、锚字符，匹配位置的字符。 2、^和$ 3、\\b和\\B 4、先行断言和后行断言 案例 1、不匹配任何东西 2、数字的千位分隔符表示法 3、替换法 4、验证密码 三、正则表达式括号作用 分组和分支结构 一、分组和分支结构 二、引用分组 三、反向引用 1、括号嵌套的时候，以左括号为准 2、\\10表示什么呢 3、引用不存在的分组 四、非捕获分组 正则表达式 一、正则表达式字符匹配 创建正则表达式 var reg = /hello/ //字面量创建 console.log(reg); var reg = new RegExp(hello)//构造函数创建 正则表达式方法 1)test （正则方法）🏳‍🌈 正则 在前面 字符串 在后面 检测出该字符串是否符合正则表达式 var str = \"hello\" //原生 var reg = /hello/ console.log(reg.test(str)); //true 在hello外面new一个数 var str = \"hello我是在外面new一个\" //在外面就可以 var reg = /hello/ console.log(reg.test(str)); //true 在hello里面new一个数 var str = \"hell我是在里new一个o\" //在里面就不可以了 var reg = /hello/ console.log(reg.test(str)); //false 2) search （字符串方法） 字符串 在前面正则 在后面 检索 出字符串符合正则的字符的索引值 var str = \"hello world\" var reg = /world/ console.log(str.search(reg));//6 3) match(字符串方法) 字符串 在前面正则 在后面 在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null var str = \"hello world\" var reg = /l/ console.log(str.match(reg)); //[\"l\", index: 2, input: \"hello world\", groups: undefined] var str = \"hello world\" var reg = /p/ //p不在字符串中就会返回null console.log(str.match(reg));//null 4) exec(正则方法) 🏳‍🌈 正则 在前面 字符串 在后面 在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null var str = \"hello world\" var reg = /l/ console.log(reg.exec(str)); //[\"l\", index: 2, input: \"hello world\", groups: undefined] 5) replace（字符串方法） 字符串 在前面正则 在后面 查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容 var str = \"hello world\" var reg = /o/ console.log(str.replace(reg, \"a\")); //hella world 加个g就可以替换后面的o咯 var str = \"hello world\" var reg = /o/g //这里加个g就可以替换后面的o咯 console.log(str.replace(reg, \"a\")); //hella warld 案例 打印出hello world里面每一个l的索引值 var str = \"hello world\" var reg = \"l\" var arr = str.split(\"\")//转换数组 // console.log([...new Set(arr)]);//这里是可以去重 //[\"h\", \"e\", \"l\", \"o\", \" \", \"w\", \"r\", \"d\"] arr.forEach(function (item, idx) { if (item === reg) { console.log(idx); //2,3,9 } }) 修饰符 1) 加的【i】 var str = \"hello world\" var reg = /HELLO/ console.log(reg.test(str));//false i可以让正则对大小写不敏感 var str = \"hello world\" var reg = /HELLO/i console.log(reg.test(str));//true 2 )加的【g】🐱‍👤 g可以让正则匹配 所有 的字符串 var str = \"hello wold\" var reg = /l/g console.log(str.match(reg));//(3) [\"l\", \"l\", \"l\"] 3) 加的【m】 m可以匹配换行注意： 只有当目标字符串 含有\\n 【\\n是换行哦】 而且正则表达式 中含有^或$的时候，/m修饰符才有作用 var str = \"a0b\\na1b\\na2b\\na3b\\na4b\" var reg = /^a[1-3]b$/m console.log(reg.test(str));//true 纵向模糊匹配🚓 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 let str = \"a1b a2b a3b a4b a5b\" let reg = /a[12345]b/g console.log(str.match(reg))//[\"a1b\", \"a2b\", \"a3b\"] 1、字符组 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。 1) 范围表示 如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。 //匹配a20 a30 a40 let str = \"a10 a20 a30 a40 a50\" let reg = /a[2-4]0/g console.log(str.match(reg)) //匹配b c d let str = \"a b c d e\" let reg = /[b-d]/g console.log(str.match(reg)) //匹配所有的数字 let str = \"1 2 3 4 5\" let reg = /[0-9]/g console.log(str.match(reg)) //匹配所有的大小写英文字母 let str = \"a b c d e A B C D\" let reg = /[A-Za-z]/g console.log(str.match(reg)) //匹配 a - z let str = \"a - z\" let reg = /[a\\\\-z]/g 或 /[az-]/g 或 /[-az]/g console.log(str.match(reg)) 练习中💨 数字匹配 var str = \"5.5\" var reg = /[1-9]/ console.log(reg.test(str));//true var str = \"1000\" var reg = /[1-9]/ console.log(reg.test(str));//true var str = \"55000\" var reg = /[1-9]/ console.log(reg.test(str));//true 英文匹配 var str = \"d\" var reg = /[a-z]/ console.log(reg.test(str));//true // 英文大小写 var str = \"A\" var reg = /[A-Ca-c]/ console.log(reg.test(str));//true var str = \"D\" var reg = /[A-Ca-c]/ console.log(reg.test(str));//false 2) 排除字符组 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是\"a\"、\"b\"、\"c\"。 //匹配除了abc以外的英文字母 let str = \"d e f g h i j k\" let reg = /[^abc]/g console.log(str.match(reg)) 练习中💨 取反 var str = \"d\" var reg = /[^abc]/ console.log(reg.test(str));//true var str = \"a\" var reg = /[^abc]/ console.log(reg.test(str));//false var str = \"c\" var reg = /[^abc]/ console.log(reg.test(str));//true 3) 字符组简写 \\\\d就是[0-9]。表示是一位数字。 \\\\D就是[^0-9]。表示除数字外的任意字符。 \\\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。 \\\\W是[^0-9a-zA-Z_]。非单词字符。 \\\\s是[\\\\t\\\\v\\\\n\\\\r\\\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 \\\\S是[^\\\\t\\\\v\\\\n\\\\r\\\\f]。 非空白符。 .就是[^\\\\n\\\\r\\\\u2028\\\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。 //匹配所有的数字 let str = \"1 2 3\" let reg = /\\\\d/g console.log(str.match(reg)) //匹配所有的英文字母和下划线 let str = \"a b c _\" let reg = /\\\\w/g console.log(str.match(reg)) //匹配所有特殊符号(表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符) let str = \"a b c _\" let reg = /\\\\s/g console.log(str.match(reg)) //通配符（表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外） let str = \"a b c _\" let reg = /./g console.log(str.match(reg)) 大法中🐱‍👤💨 // 数字匹配简写 // 取反 // \\d就是[0 - 9]。表示是一位数字。💖 // \\D就是[^ 0 - 9]。表示除数字外的任意字符。 var str = \"s\" var reg = /\\D/ console.log(reg.test(str));//true var str = \"g\" var reg = /\\D/ console.log(reg.test(str));//true var str = \"H\" var reg = /\\a/ console.log(reg.test(str));//false var str = \"j\" var reg = /\\a/ console.log(reg.test(str));//false // 表示数字、大小写字母和下划线。\\w就是[0-9a-zA-Z_]💖 var str = \"-\" var reg = /\\w/ console.log(reg.test(str));//false var str = \"-j\" var reg = /\\w/ console.log(reg.test(str));//true var str = \"1\" var reg = /\\w/ console.log(reg.test(str));//true var str = \"_\" var reg = /\\w/ console.log(reg.test(str));//true //\\s是[\\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 // 大写S就取反 var str = \"\\n\" var reg = /\\s/ console.log(reg.test(str));//true var str = \"$\" var reg = /\\s/ console.log(reg.test(str));//false var str = \"$\" var reg = /\\S/ console.log(reg.test(str));//true // 通用 var str = \"j\" var reg = /./ console.log(reg.test(str));//true //无敌什么都能匹配 var str = \"\\n\" var reg = /[\\w\\w]/ console.log(reg.test(str));//false var str = \"^%\" var reg = /[\\w\\D]/ console.log(reg.test(str));//true // 这种什么都匹配不了 var str = \"$\" var reg = /[^\\d\\D]/ console.log(reg.test(str));//false // 特殊用法💨 var str = \"1\" var reg = /[\\w\\w]/ //匹配所有字符 console.log(reg.test(str));//true var reg = /[^\\w\\w]/ //不匹配任何字符 console.log(reg.test(str));//false //匹配a20 a30 a40 var str = \"a10 a20 a30 a40 a50\" var reg = /a[2-4]0/g console.log(reg.test(reg))//false console.log(str.match(reg))//[\"a20\", \"a30\", \"a40\"] //匹配b c d var str = \"a b c d e\" var reg = /[b-d]/g console.log(reg.test(reg))//true console.log(str.match(reg))// [\"b\", \"c\", \"d\"] //匹配所有的数字 var str = \"1 2 3 4 5\" var reg = /[0-9]/g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"1\", \"2\", \"3\", \"4\", \"5\"] //匹配所有的大小写英文字母 var str = \"a b c d e A B C D\" var reg = /[A-Za-z]/g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"a\", \"b\", \"c\", \"d\", \"e\", \"A\", \"B\", \"C\", \"D\"] //匹配 a - z var str = \"a - z\" var reg = /[a\\\\-z]/g //或 /[az-]/g 或 / [-az] / g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"a\", \"z\"] 横向模糊匹配 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 //匹配abbc abbbc let str = \"abc abbc abbbc\" let reg = /ab{2,3}c/g console.log(str.match(reg)) 1、量词 量词也称重复。 {m,} 表示至少出现m次。 {m} 等价于{m,m}，表示出现m次。 ? 等价于{0,1}，表示出现或者不出现。 + 等价于{1,}，表示出现至少一次。 * 等价于{0,}，表示出现任意次，有可能不出现。 //匹配出现0次或1次 let str = \"ac abc abbc abbbc\" let reg = /ab{0,1}c/g let reg= /ab?c/g console.log(str.match(reg)) //[\"ac\", \"abc\"] //匹配出现至少一次 let str = \"ac abc abbc abbbc\" let reg = /ab{1,}c/g let reg= /ab+c/g console.log(str.match(reg)) //[\"abc\", \"abbc\", \"abbbc\"] //匹配出现任意次数 let str = \"ac abc abbc abbbc\" let reg= /ab*c/g console.log(str.match(reg)) // [\"ac\", \"abc\", \"abbc\", \"abbbc\"] 练习中💨 var str = \"heo helo hello helllo hellllo\" var reg = /hel{1,3}o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\"] var str = \"heo helo hello helllo hellllo\" var reg = /hel{1,}o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\", \"hellllo\"] var str = \"heo helo hello helllo hellllo\" var reg = /hel{2}o/g console.log(str.match(reg));//[\"hello\"] //【?】0次或者1次 var str = \"heo helo hello helllo hellllo\" var reg = /hel?o/g console.log(str.match(reg));//[\"heo\", \"helo\"] //【+】至少出现了1次 var str = \"heo helo hello helllo hellllo\" var reg = /hel+o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\", \"hellllo\"] //【*】任意次数 var str = \"heo helo hello helllo hellllo\" var reg = /hel*o/g console.log(str.match(reg));//[\"heo\", \"helo\", \"hello\", \"helllo\", \"hellllo\"] 案例 1、匹配我们的手机号码（松散匹配） 1[3-9]后面9位数字 var str = \"15866393005\"; var reg = /^1[3-9]\\d{9}$/ console.log(reg.test(str)); //true 用判断语句 var str = \"15866393005\"; var reg = /^1[3-9]\\d{9}$/ var arr = reg.exec(str) if (arr === null || arr === \"\") { alert(\"没匹配!\") } else { alert(arr[0]) //15866393005 } 2、qq邮箱 var str = \"15866393@qq.com\" var reg = /^[1-9][0-9]{4,10}@qq.com$/ console.log(reg.test(str));//true 3、24小时正则式 // 23:59 // 00:00 // 09 // 19 // 23 var str = \"24:00\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//false var str = \"00:00\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true var str = \"23:59\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true 2、贪婪匹配和惰性匹配 量词默认都是贪婪匹配的，即有多少个就匹配多少个，越多越好。 let str = \"123 1234 12345 123456\" let reg = /\\\\d{2,5}/g console.log(str.match(reg))//[\"123\", \"1234\", \"12345\", \"12345\"] 而有时候我们可能需要的是惰性匹配，即尽可能少的匹配。 //其中/\\\\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。 let str= \"123 1234 12345 123456\"; let reg= /\\\\d{2,5}?/g; console.log( str.match(reg) )//[\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"] 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下 {m,n}? {m,}? ?? +? *? 多选分支 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 let str = \"hello world\" let reg = /hello|world/g console.log(str.match(reg))//[hello,world] 但是多选分支默认是惰性的 let str = \"good goodbye\" let reg = /good|goodbye/g console.log(str.match(reg))//['good', 'good'] 可以这么写 let str = \"good goodbye\" let reg = /goodbye|good/g//把goodbye放前面就可以准确的获取到goodbye console.log(str.match(reg))//['good', 'goodbye'] let str = \"good goodbye\" let reg = /^good|goodbye$/g//^$是以什么为开头，什么味结束 console.log(str.match(reg))//['good', 'goodbye'] 案例 1、匹配16进制颜色值 #ffbbad #Fc01DF #FFF #ffE var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; var string = \"#ffbbad #Fc01DF #FFF #ffE\"; console.log( string.match(regex) ); // => [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 2、匹配24小时制时间 23:59 02:07 var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/; console.log( regex.test(\"23:59\") ); console.log( regex.test(\"02:07\") ); // => true // => true 3、匹配日期,yyyy-mm-dd格式 var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; console.log( regex.test(\"2017-06-10\") ); // => true 二、正则表达式位置匹配 位置 位置指的是相邻字符之间的位置。 //可以把位置理解成每一个字符左右两边的空字符 let str = \"hello\" let str = \"\"+\"h\"+\"e\"+\"l\"+\"l\"+\"o\"+\"\" 位置匹配 1、锚字符，匹配位置的字符。 ^ //（脱字符）匹配开头，在多行匹配中匹配行开头。 $ //（美元符号）匹配结尾，在多行匹配中匹配行结尾。 \\\\b //\\\\w和\\\\W之间的位置，也包括\\\\w和^之间的位置，也包括\\\\w和$之间的位置。 \\\\B //\\\\w与\\\\w、\\\\W与\\\\W、^与\\\\W，\\\\W与$之间的位置 (?=p) //正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 (?!p) //负向先行断言。(?!p)，就是(?=p)的反面意思 (? 练习中💨 //【^】（脱字符）匹配开头，在多行匹配中匹配行开头。 var str = \"hello heooo llo\" var reg = /^he/g console.log(str.match(reg));//[\"he\"] var str = \"hello heooo llo\" var reg = /he$/g console.log(str.match(reg));//null // 【$】（美元符号）匹配结尾，在多行匹配中匹配行结尾。 var str = \"hello heooo llo\" var reg = /llo$/g console.log(str.match(reg));//[\"llo\"] var str = \"hello heooo llo\" var reg = /^llo/g console.log(str.match(reg));//null // 【\\\\b】 \\\\w和\\\\W之间的位置，也包括\\\\w和^之间的位置，也包括\\\\w和$之间的位置。 var str = \"h e l l o\" var reg = /\\b/g console.log(str.replace(reg, \"#\"));//#h# #e# #l# #l# #o# // 【\\\\B】 \\\\w与\\\\w、\\\\W与\\\\W、^与\\\\W，\\\\W与$之间的位置 var str = \"hello\" var reg = /\\B/g console.log(str.replace(reg, \"#\"));//h#e#l#l#o var str = \"h e l l o\" var reg = /\\B/g console.log(str.replace(reg, \"#\"));//h e l l o 💨🐱‍👤 // 【(?= p)】 正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 var str1 = \"hello\" var reg1 = /(?=l)/g console.log(str1.replace(reg1, \"#\"));//he#l#lo // 【(? !p)】 负向先行断言。(?!p)，就是(?=p)的反面意思 var str2 = \"hello\" var reg2 = /(?!l)/g console.log(str2.replace(reg2, \"#\"));//#h#ell#o# // 【(? 案例 // 12345678 变成 12,345,678 var str = \"12345678\" var reg = /(?!^)(?=(\\d{3})+$)/g console.log(str.replace(reg, \",\"));//12,345,678 相识-半 var str = \"123456789\" var reg = /(? 2、^和$ ^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 let str = \"hello\" let reg = /^|$/g console.log(str.replace(reg,\"#\"))//#hello# 要注意多行匹配模式时，二者是行的概念 let str = \"i\\\\nlove\\\\njavascript\" let reg = /^|$/g console.log(str.replace(reg,\"#\")) // #i // love // javascript# //需要加修饰符m let str = \"i\\\\nlove\\\\njavascript\"; let reg = /^|$/gm; console.log(str.replace(reg, \"#\")); // #i# // #love# // #javascript# 3、\\b和\\B \\b是单词边界，具体就是\\w和\\W之间的位置，也包括\\w和^之间的位置，也包括\\w和$之间的位置。 let str = \"[JS] Lesson_01.mp4\"; let reg = /\\\\b/g; console.log(str.replace(reg, \"#\"));//[#JS#] #Lesson_01#.#mp4# \\B就是\\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\\b，剩下的都是\\B的。 具体说来就是\\w与\\w、\\W与\\W、^与\\W，\\W与$之间的位置。 let str = \"[JS] Lesson_01.mp4\"; let reg = /\\\\B/g; console.log(str.replace(reg, \"#\"));//#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4 4、先行断言和后行断言 先行断言和后行断言也被称为环视。 正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 let str = \"hello\"; let reg = /(?=l)/g; console.log(str.replace(reg, \"#\"));//he#l#lo 负向先行断言。(?!p)，就是(?=p)的反面意思 let str = \"hello\"; let reg = /(?!l)/g; console.log(str.replace(reg, \"#\"));//#h#ell#o# 正向后行断言。(?，即p后面的位置。 let str = \"hello\"; let reg = /(? 负向后行断言。(?，就是(?的反面意思 let str = \"hello\"; let reg = /(? 案例 1、不匹配任何东西 let str = \"hello\"; let reg = /.^/g; console.log(str.match(reg))//null 2、数字的千位分隔符表示法 把\"12345678\"，变成\"12,345,678\"。 let str = \"123456789\"; let reg = /(?!^)(?=(\\\\d{3})+$)/g; console.log(str.replace(reg,\",\"))//123,456,789 3、替换法 把\"12345678 123456789\"替换成\"12,345,678 123,456,789\" let str = \"12345678 123456789\"; let reg = /\\\\B(?=(\\\\d{3})+\\\\b)/g; console.log(str.replace(reg,\",\"))//12,345,678 123,456,789 4、验证密码 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。 同时包含数字和小写字母 同时包含数字和大写字母 同时包含小写字母和大写字母 同时包含数字、小写字母和大写字母 let str = \"123abcdef112\"; let reg = /((?=.*\\\\d)(?=.*[a-z])|(?=.*\\\\d)(?=.*[A-Z])|(?=.*[A-Z])(?=.*[a-z]))^[0-9A-Za-z]{6,12}$/g; console.log(reg.test(str))//true 另外一种解法 不能是纯数字 不能是纯小写 不能是纯大写 let str = \"AAAAAA\"; let reg = /(?!^\\\\d{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/; console.log(reg.test(str))//false 三、正则表达式括号作用 分组和分支结构 一、分组和分支结构 分组 var regex = /(ab)+/g; var string = \"ababa abbb ababab\"; console.log( string.match(regex) ); // => [\"abab\", \"ab\", \"ababab\"] 分支结构 var regex = /^I love (JavaScript|Regular Expression)$/; console.log( regex.test(\"I love JavaScript\") ); console.log( regex.test(\"I love Regular Expression\") ); // => true // => true 二、引用分组 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。 提取数据 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(reg.test(str))//任意的正则操作,以下都可以 // console.log(reg.exec(str)) // console.log(str.match(reg)) //通过构造函数的全局属性$1至$9来获取 console.log(RegExp.$1)//2021 console.log(RegExp.$2)//2021 console.log(RegExp.$3)//2021 替换数据 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(str.replace(reg,\"$2/$3/$1\"))//10/06/2021 //等价于 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(str.replace(reg,()=>{ return RegExp.$2 + \"/\" + RegExp.$3 + \"/\" + RegExp.$1 })) 三、反向引用 除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。 //\\\\1的意思是引用前面的(-|\\\\/|\\\\.)分组 let reg = /\\\\d{4}(-|\\\\/|\\\\.)\\\\d{2}\\\\1\\\\d{2}/; let str1 = \"2021-10-06\"; let str2 = \"2021/10/06\"; let str3 = \"2021.10.06\"; let str4 = \"2021-10/06\"; console.log(reg.test(str1))//true console.log(reg.test(str2))//true console.log(reg.test(str3))//true console.log(reg.test(str4))//false 1、括号嵌套的时候，以左括号为准 let reg = /^((\\\\d)(\\\\d(\\\\d)))\\\\1\\\\2\\\\3\\\\4$/; let str1 = \"1231231233\"; console.log(reg.test(str1))//true console.log(RegExp.$1)//123 console.log(RegExp.$2)//1 console.log(RegExp.$3)//23 console.log(RegExp.$4)//3 2、\\10表示什么呢 \\10是表示第10个分组，不是表示\\1和0 var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\\\10+/; var string = \"123456789# ######\" console.log( regex.test(string) ); // => true 3、引用不存在的分组 因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。 var regex = /\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9/; console.log( regex.test(\"\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9\") ); console.log( \"\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9\".split(\"\") ); 四、非捕获分组 如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)。 var regex = /(?:ab)+/g; var string = \"ababa abbb ababab\"; console.log( string.match(regex) ); // => [\"abab\", \"ab\", \"ababab\"] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"17异常错误对象.html":{"url":"17异常错误对象.html","title":"17异常错误对象","keywords":"","body":" 1、常见的错误类型 2、错误捕捉语句 3、抛出一个异常 4、最终语句 异常错误对象 1、常见的错误类型 console.log(num); //这种就直接报错红色 //RangeError 已发生超出数字范围的错误 var num = 1; try { num.toPrecision(500); // 数无法拥有 500 个有效数 } catch(err) { } //ReferenceError 已发生非法引用✨ var x; try { x = y + 1; // y 无法被引用（使用） } catch(err) { } //SyntaxError 已发生语法错误✨ try { eval(\"alert('Hello)\"); // 缺少 ' 会产生错误 } catch(err) { } //TypeError 已发生类型错误✨ var num = 1; try { num.toUpperCase(); // 您无法将数字转换为大写 } catch(err) { } //URIError 在 encodeURI() 中已发生的错误 try { decodeURI(\"%%%\"); // 您无法对这些百分号进行 URI 编码 } catch(err) { } 2、错误捕捉语句 //try 语句允许您定义一个代码块，以便在执行时检测错误 //catch 语句允许你定义一个要执行的代码块，如果 try 代码块中发生错误 //e是 Error 错误对象 name 错误的名字 message 错误的信息 try{ }catch(e){ } 3、抛出一个异常 //throw允许您创建自定义错误 throw throw \"Too big\"; // 抛出文本 throw 500; //抛出数字 //案例 var a = 1; try{ console.log(b); }catch(e){ if(e.name === \"ReferenceError\"){ throw \"你是不是没有定义该变量?\" throw new Error(\"是否没有定义变量\") } } 4、最终语句 //finally允许您在 try 和 catch 之后执行代码，无论结果 finally //案例 var a = 1; try{ console.log(b); }catch(e){ console.log(e) } finally{ console.log(\"无论对错，都会执行这里的语句\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"18BOM浏览器对象模型.html":{"url":"18BOM浏览器对象模型.html","title":"18BOM浏览器对象模型","keywords":"","body":" 1、计时器 1)无限计时器 2)一次性计时器 3)清空无限计时器 4)清空一次性计时器 2、页面栈对象和历史对象 3、本地缓存 1)存储和获取 2)删除单个 3)清空所有 案例 BOM 浏览器对象模型 1、计时器 1)无限计时器 let i = 0 setInterval(()=>{ i++ console.log(i) },1000)//这里毫秒为单位 // 无限次计时器【简写】 setInterval(function () { console.log(123);// }, 2000) 2)一次性计时器 let i = 0 function timeHandler() { setTimeout(() => { i++ console.log(i) timeHandler() }, 1000);//这里毫秒为单位 } timeHandler() // 一次性计时器 【简写】 setTimeout(function () { console.log(123); }, 2000)//这里毫秒为单位 案例 // 使用一次性计时器，实现无限次计时器的效果 function fn() { setTimeout(function () { console.log(\"这是一次性计时器哦！\"); fn()//递归 }, 1000) } fn() //自己执行自己 function fn() { fn()//递归 } //回调是把别的函数当成参数执行 function fn(f) { f() } 3)清空无限计时器 let i = 0 let timer = setInterval(()=>{ i++ console.log(i) },1000) clearInterval(timer) 4)清空一次性计时器 let timer = setTimeout(() => { i++; console.log(i); timeHandler(); }, 1000); clearTimeout(timer); 案例 按钮 //3)清空无限计时器 var timeHandler = setInterval(function () { console.log(123); }, 1000) var btn = document.querySelector(\"button\") btn.onclick = function () { clearInterval(timeHandler) } 清空即开始 暂停 开始 var timeHandler var i = 0 function time() { timeHandler = setInterval(function () { console.log(++i); }, 1000) } //开始 var start = document.querySelector(\".start\") start.onclick = function () { clearInterval(timeHandler) time() } //暂停 var stop = document.querySelector(\".stop\") stop.onclick = function () { clearInterval(timeHandler) i = 0 } 2、页面栈对象和历史对象 跳到a页面 let btn = document.querySelector(\"button\") btn.onclick = ()=>{ location.href = \"a.html\"//location是页面栈对象，记录了跳转页面的信息 } 返回首页 let btn = document.querySelector(\"button\") btn.onclick = ()=>{ // history.back() history.go(-1)//history是历史记录对象，记录了每一次跳转的信息 } 3、本地缓存 前端： cookie; localStorage; sessionStorage; 后端： session; session；后端才有使用，跟前端没有关系。 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage;本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage;本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 微信小程序 1、有同步异步 2、不限于只存储字符串，可以直接存对象 1)存储和获取 //默认只能存字符串 localStorage.setItem(\"name\",\"小明\") console.log(localStorage.getItem(\"name\")) //存数组需要先转json字符串 localStorage.setItem(\"obj\",JSON.stringify({name:\"小明\"})) console.log(JSON.parse(localStorage.getItem(\"obj\"))) 2)删除单个 localStorage.removeItem() 3)清空所有 localStorage.clear() 案例 //存 localStorage.setItem(\"name\", \"小明\") //取 console.log(localStorage.getItem(\"name\")); localStorage.setItem(\"bool\", true) console.log(localStorage.getItem(\"bool\")); localStorage.setItem(\"arr\", JSON.stringify([{ name: \"小明\", age: 18 }])) console.log(JSON.parse(localStorage.setItem(\"arr\"))); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"19DOM文档对象模型.html":{"url":"19DOM文档对象模型.html","title":"19DOM文档对象模型","keywords":"","body":" 1、查找html元素 2、改变html元素 3、添加和删除元素 4、Element 对象 1)元素属性 2)元素位置和尺寸 3)节点导航 4)添加和删除元素 5、Attr 对象 6、Event 对象 1)事件句柄(Event Handlers) 2)鼠标 / 键盘属性 3）事件传播 4)event属性 5）标准Event方法 7、事件监听器 8、事件委托 案例 DOM文档对象模型 1、查找html元素 //通过元素 id 来查找元素 document.getElementById(id) //通过标签名来查找元素 document.getElementsByTagName(name) //通过类名来查找元素 document.getElementsByClassName(name) //根据选择器来查找元素 document.querySelector() //根据选择器来查找元素集合 document.querySelectorAll() 练习中💨 旧版【不建议使用，仅参考】 我是id // id属性 var div = document.getElementById(\"a\") console.log(div); // class属性 var div = document.getElementsByClassName(\"a\") console.log(div); // 标签属性 var div = document.getElementsByTagName(\"div\") console.log(div); 获取子元素的内容【不建议使用，仅参考】 我司a 我是b 我是c var a = document.getElementsByClassName(\"a\")[0] var b = a.getElementsByClassName(\"b\")[0] var c = b.getElementsByClassName(\"c\")[0] console.log(c.innerHTML);//我是c 新版 我是id // class属性 【获取一个】 var div = document.querySelector(\".a .b .c\") console.log(div); // div属性 【获取多个】 var div = document.querySelectorAll(\"div\") console.log(div); // class属性 【多个下层】 var div = document.querySelectorAll(\".a .b,.c\") console.log(div); 2、改变html元素 //改变元素的 inner HTML【包含标签】 element.innerHTML = new html content //获取内容【只更改内容】 innerText //获取HTML 元素的属性值 element.attributes //例 var a = document.querySelector(\"a\") a.attributes.href = \"www.sina.com\" //改变 HTML 元素的属性值 element.setAttribute(attribute, value) //例 var a = document.querySelector(\"a\") a.setAttribute(\"href\",\"www.sina.com\") //改变 HTML 元素的样式 element.style.property = new style 练习中💨 内容 //改变元素的 inner HTML【包含标签】 var div=document.querySelector(\".a\") div.innerHTML=\"innerHTML改变内容和标签\" 内容 //获取HTML 元素的属性值 var div=document.querySelector(\".a\") console.log(div.attributes); 3、添加和删除元素 //创建 HTML 元素 document.createElement(element) //删除 HTML 元素 document.removeChild(element) //删除元素 document.remove() //添加 HTML 元素 document.appendChild(element) //替换 HTML 元素 document.replaceChild(element) //写入 HTML 输出流(会覆盖文档) document.write(text) 练习中💨 var body = document.querySelector(\"body\")//获取body var div = document.createElement(\"div\")//创建div div.innerHTML = \"创建div\"//给div添加内容 body.appendChild(div)//插入到body里面 4、Element 对象 1)元素属性 //返回元素属性的 NamedNodeMap element.attributes //设置或返回元素的 class 属性 element.className //返回元素节点的指定属性值 element.getAttribute() //把指定属性设置或更改为指定值 element.setAttribute() //设置或返回元素的 id element.id //设置或返回元素的内容 element.innerHTML //返回元素的名称 element.nodeName //从元素中移除指定属性 element.removeAttribute() //设置或返回元素的 style 属性 element.style //返回元素的标签名 element.tagName 练习中💨 div //attributes:div属性 //elemen:获取的代码 var div=document.querySelector(\"div\") div //设置或返回元素的 class 属性 var div=document.querySelector(\"div\") console.log(div.className);//a //返回元素的名称 //获取B站的所有标签符 console.log( [ ...new Set( [...document.querySelectorAll(\"*\")].map((item) => item.nodeName) ), ].length ); div //更改颜色 //设置或返回元素的 style 属性 var body = document.querySelector(\"body\")//获取body div.style.color = \"red\" 2)元素位置和尺寸 //返回元素的可见高度【本质上的高】 element.clientHeight //返回元素的可见宽度【本质上的宽】 element.clientWidth //返回元素的高度【实际看到的高】 element.offsetHeight //返回元素的宽度【实际看到的宽】 element.offsetWidth //返回元素的水平偏移位置 element.offsetLeft //返回元素的垂直偏移位置 element.offsetTop 练习中💨 div //返回元素的可见高度【本质上的高】 var div=document.querySelector(\"div\") console.log(div.clientHeight);//100 div //返回元素的可见宽度【本质上的宽】 var div=document.querySelector(\"div\") console.log(div.clientWidth);//100 3)节点导航 //返回元素子节点的 NodeList element.childNodes //返回元素的首个子集 element.firstChild //返回元素的最后一个子元素 element.lastChild //返回元素的父节点 element.parentNode //返回当前节点的下一个节点 element.nextSibling //返回当前节点的上一个节点 element.previousSibling 练习中💨 a a a //返回元素子节点的 NodeList var div=document.querySelector(\".box\") console.log(div.childNodes);//[text, div.a, text, div.a, text, div.a, text] //text是空格 //返回元素的首个子集 var div=document.querySelector(\".box\") console.log(div.firstChild);//[#text] a1 a2 a3 //返回元素的父节点 var a1=document.querySelector(\".a1\") console.log(a1.parentNode);//div.box //返回当前节点的下一个节点 var a1=document.querySelector(\".a1\") console.log(a1.nextSibling); 4)添加和删除元素 //向元素添加新的子节点，作为最后一个子节点 element.appendChild() //在指定的已有的子节点之前插入新节点 element.insertBefore() //克隆元素 element.cloneNode() //从元素中移除子节点 element.removeChild() 练习中💨 a1 a2 a3 //在指定的已有的子节点之前插入新节点 var box = document.querySelector(\".dox\")//获取class box var x = document.createElement(\"div\")//创建div x.innerHTML = \"我是新的x\" //新建添加内容 box.insertBefore(x, box.childNodes[0]) //在box属性前面添加内容 //向元素添加新的子节点，作为最后一个子节点 var box = document.querySelector(\".dox\")//获取class box var x = document.createElement(\"div\")//创建div x.innerHTML = \"我是新的x\" //新建添加内容 box.appendChild(x) //在box属性后面添加内容 a1 a2 a3 //克隆元素【放进box后面去】 var box=document.querySelector(\".box\") //这里是获取box属性 var a1=document.querySelector(\".a1\") //先获取a1属性 var a1Clone=a1.cloneNode() //这里是克隆a1 a1Clone.innerHTML=\"我是克隆a1\"//新建添加内容 box.appendChild(a1Clone) //这里是把a1克隆放进box后面去 5、Attr 对象 //返回属性的名称 attr.name //设置或返回属性的值 attr.value 6、Event 对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态 1)事件句柄(Event Handlers) //图像的加载被中断 onabort //元素获得焦点(记) onfocus //元素失去焦点(记) onblur //域的内容被改变(记) onchange //当用户点击某个对象时调用的事件句柄(记) onclick //当用户双击某个对象时调用的事件句柄 ondblclick //在加载文档或图像时发生错误 onerror //某个键盘按键被按下 onkeydown //某个键盘按键被按下并松开 onkeypress //某个键盘按键被松开 onkeyup //一张页面或一幅图像完成加载(记) onload //鼠标按钮被按下 onmousedown //鼠标被移动 onmousemove //鼠标从某元素移开 onmouseout //鼠标移到某元素之上(记) onmouseover //鼠标按键被松开 onmouseup //重置按钮被点击 onreset //窗口或框架被重新调整大小 onresize //文本被选中 onselect //确认按钮被点击(记) onsubmit 练习中💨 内容 //当用户点击某个对象时调用的事件句柄(记) 【点击生产告示我们事件叫什么名字和值】 var a=doc.querySelector(\".a\") //获取a属性 a.onclick=function(event){ //这里是点击产生事件 //event：是形参 ——可任意字母 console.log(event); //打印事件 } //元素获得焦点(记) onfocus 【点击里面就会失去】 var a = document.querySelector(\".a\") //获取a属性 a.onfocus = function () {//获取焦点✨💖 console.log(\"点击里面获取\"); //打印 } //元素失去焦点(记) onblur 【点击外面就会失去】 a.onblur = function () {//失去焦点✨💖 console.log(\"点击外面失去\"); //打印 } 域的内容被改变(记) onchange //域的内容被改变(记) onchange var a=document.querySelector(\".a\") //获取a属性 a.onchange=function(){ console.log(123); //【这里就输入内容就会打印123哦】 } 广州 威武 深圳 //域的内容被改变 onchange var a = document.querySelector(\".city\") a.onchange = function (event) { console.log(event.target.value); //【获取选择的对象】 } //域的内容被改变(记) onchange var a=document.querySelector(\".a\") //获取a属性 a.onchange=function(evwnt){ console.log(event.target.value); //【输入内容就获取】 } //一张页面或一幅图像完成加载(记) // onload window.onload = function () { console.log(window); } 这里就用得最最多了💖✨🚀 账号 提交 //确认按钮被点击(记) // onsubmit var form = document.querySelector(\".form\") form.onsubmit = function () { console.log(123); } 2)鼠标 / 键盘属性 //返回当事件被触发时，鼠标指针的水平坐标 clientX //返回当事件被触发时，鼠标指针的垂直坐标 clientY 3）事件传播 1、事件捕获 【父级元素传播到触发的子级元素上（只有低版本Ie浏览器是捕获事件）】 2、事件派发发阶段 【传递过程】 3、事件冒泡 【触发的元素往父级元素传播】 4)event属性 //返回其事件监听器触发该事件的元素 currentTarget //返回触发此事件的元素（事件的目标节点） target //target和currentTarget的区别（重点必记） currentTarget 绑定该事件的元素 【跟冒泡事件】 target 触发了事件的元素 //返回事件传播的当前阶段 eventPhase 捕获阶段 1 事件派发 2 冒泡阶段 3 //返回事件生成的日期和时间(时间戳) timeStamp //返回当前 Event 对象表示的事件的名称 type 练习中💨💖✨ .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 比如：3 点击这元素就网上传播 比如：2 function eventHandler(e) { console.log(e.eventPhase);//返回事件传播的当前阶段eventPhase } target和currentTarget的区别（重点必记）✨✨✨ .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 比如：3 点击这元素就网上传播 比如：2 //target和currentTarget的区别（重点必记） function eventHandler(e) { console.log(e.currentTarget); //放定该事件的元素 【用这里点击是：2 3】💥 console.log(e.target); //触发了事件的元素 【用这里点击是：2】💥 } 5）标准Event方法 //通知浏览器不要执行与事件关联的默认动作(取消事件的默认行为) preventDefault() //不再派发事件 stopPropagation() 练习中preventDefault()💨 按钮 function sumbit(e) { e.preventDefault() //表单取消事件的默认行为【就是不让他消失永久显示在控制台上】 console.log(123); } 不再派发传播事件stopPropagation()💨 .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 我是a 我是b //不再派发事件💥 【】 function eventHandler(e) { e.stopPropagation() console.log(e.currentTarget); //2 } 7、事件监听器 //第一个参数是事件的类型（比如 \"click\" 或 \"mousedown\"） //第二个参数是当事件发生时我们需要调用的函数 //第三个参数是布尔值，指定使用事件冒泡还是事件捕获。此参数是可选的 element.addEventListener(event, function, useCapture) //removeEventListener()删除事件监听 element.removeEventListener(\"mousemove\", myFunction) 练习中💨 内容 var div = document.querySelector(\"div\") div.onclick = function () { console.log(\"我是事件监听器，第一种\"); } 内容 var div = document.querySelector(\"div\") div.addEventListener(\"click\", function () { console.log(\"我是事件监听器，第二种\"); }) 内容 var div = document.querySelector(\"div\") //获取元素 function eventHandler() {//这个函数只是打印123 console.log(123); } div.addEventListener(\"click\", eventHandler) //这里是触发函数【用这个控制台就打印123咯】 div.removeEventListener(\"click\", eventHandler) //这里是清除【用这个控制台上是什么也没有哦】 8、事件委托 目的：减少代码执行优化资源 原理：在目标集合元素的父级元素添加事件，点击目标集合元素时，因为事件冒泡的作用实现事件委托 let ul = document.querySelector(\"ul\") ul.onclick = function(event){ console.log(event.target) } ul.addEventListener(\"click\",function(event){ console.log(event.target) }) 练习中💨 1 2 3 var list = document.querySelectorAll(\"li\") list.forEach(function (item) { item.onclick = function () { console.log(123); //这里是每一个成员添加的点击事件 } }) 1 2 3 var list = document.querySelectorAll(\"li\") list.forEach(function (item) { item.onclick = function () { console.log(item.innerText); //这里是实现每一个成员点击打印相应值出来 } }) 1 2 3 var lu = document.querySelector(\"ul\") ul.onclick = function (event) { //event添加事件对象 console.log(event.target.innerText); //target事件委托 } 案例 使用下拉列表做城市联动效果，选择完国家，出现对应得城市 ==请选择国家== ==请选择城市== var arr = [ { countryName: \"中国\", cities: [ { cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"东莞\" }, ], }, { countryName: \"美国\", cities: [ { cityName: \"纽约\" }, { cityName: \"华盛顿\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cities: [ { cityName: \"大阪\" }, { cityName: \"东京\" }, { cityName: \"札幌\" }, ], }, ]; var country = document.querySelector(\".country\"); //获取country var city = document.querySelector(\".city\"); //获取city //循环迭代国家 arr.forEach(function (item) { var option = document.createElement(\"option\"); //创建一个空白的option标签 option.value = item.countryName; //设置value option.innerText = item.countryName; //设置内容 country.appendChild(option); //把option插入到country里面 }); // 每次国家切换的时候触发事件 country.onchange = function (event) { city.innerHTML = '==请选择城市==' var currentCountry = event.target.value; //获取到选中的国家 arr.forEach(function (item) { if (item.countryName === currentCountry) { //判断当前选中的国家和数据进行比较 item.cities.forEach(function (items) { console.log(items); var option = document.createElement(\"option\"); //创建一个空白的option标签 option.value = items.cityName; //设置value option.innerText = items.cityName; //设置内容 city.appendChild(option); //把option插入到country里面 }); } }); }; 这种自己了【不建议使用】 ==请选择国际== 中国 美国 日本 ==请选择国际== function setSecond(obj) { var val = obj.value; if (val == 'en') { var sec = document.getElementById('second'); sec.options[0] = new Option(\"洛杉矶\", \"one\"); sec.options[1] = new Option(\"纽约\", \"two\"); sec.options[2] = new Option(\"凤凰城\", \"three\"); } else if (val == 'jn') { var sec = document.getElementById('second'); sec.options[0] = new Option(\"东京\", \"one\"); sec.options[1] = new Option(\"北海市\", \"two\"); sec.options[2] = new Option(\"广岛\", \"three\"); } else { var sec = document.getElementById('second'); sec.options[0] = new Option(\"移动\", \"one\"); sec.options[1] = new Option(\"广州\", \"two\"); sec.options[2] = new Option(\"上海\", \"three\");//可设置循环配置，也可一个一个配置 } } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"20json.html":{"url":"20json.html","title":"20json","keywords":"","body":" 一、创建json 二、json文本和json对象的转换 json JavaScript 对象表示法(JavaScript Object Notation)。轻量级的文本数据交换格式，用来描述数据对象。 json和xml相比的优势：比xml更易读，速度更快。 一、创建json //key值必须要加双引号 //不能出现相同的Key值 //json里不能有函数和undefined //不能注释 {\"key\":\"value\"} 练习中💨 { \"name\": \"小明\", \"obj\": {}, \"arr\": {} } 相互转换 var json = { \"name\": \"小明\", \"obj\": {}, \"arr\": {} } var str = JSON.stringify(json)//把json对象转成json字符串 var obj = JSON.parse(str)//把json字符串转成json对象 console.log(obj); 二、json文本和json对象的转换 //把json文本转换成js对象 eval() eval(\"(\"+text+\")\")//不安全，会解析js代码，并且不会判断数据是否符合json格式 JSON.parse() JSON.parse(text)//推荐 //把js对象转换成json文本 JSON.stringify() Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"21Ajax.html":{"url":"21Ajax.html","title":"21Ajax","keywords":"","body":" 一、get请求 二、post请求 1. 请求报文和响应报文 2. http请求 三、get和post的区别 1. 状态码 2. 请求文本类型 3. token 四、axios 易用、简洁且高效的http库 axios中文文档 🚀 执行多个并发请求 拦截器 取消请求 Ajax async javascript xml，异步js和xml。Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。 一、get请求 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"GET\", \"\");//建立连接 xhr.send()//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; [!cogs] 获取列表接口 get请求 不用写参数 http://192.168.1.176:8080/getList var xhr if(window.XMLHttpRequest){//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 }else{//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"GET\",\"http://192.168.1.176:8080/getList\")//与服务器地址建立连接 xhr.send()//发送请求 xhr.onreadystatechange = function(){//等待服务器响应 if(xhr.readyState === 4 && xhr.status === 200){//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } 二、post请求 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"POST\", \"\");//建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 let data = { goodsId:\"b1195296679f482aa7d54d95ac2b4a94\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; [!cogs] 获取国家接口 post请求 传国家id http://192.168.1.176:8080/getCountry var xhr if(window.XMLHttpRequest){//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 }else{//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"POST\",\"http://192.168.1.176:8080/getCountry\")//与服务器地址建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 // 发给后端的参数 var data = { \"id\":\"001\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function(){//等待服务器响应 if(xhr.readyState === 4 && xhr.status === 200){//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } [warning]获取城市接口 post请求 传城市id http://192.168.1.176:8080/getCity var xhr if (window.XMLHttpRequest) {//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 } else {//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"POST\", \"http://192.168.1.219:8080/getCity\")//与服务器地址建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 var data = { \"id\": \"001002\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//等待服务器响应 if (xhr.readyState === 4 && xhr.status === 200) {//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } %accordion% 这是我们发送请求了 %accordion% %/accordion% %accordion% 请求三大块 %accordion% %/accordion% 1) 请求报文和响应报文 //发送的请求是有固定格式的 请求报文 请求行 请求地址、请求类型（请求方法）、状态代码 请求头 请求文本类型（json/form）、token（密钥） 请求体 发送的参数 响应报文 响应行 响应头 响应体 后端返回给前端的数据 请求报文 %accordion% 请求行%accordion% %/accordion% %accordion% 这是后端了 %accordion% %/accordion% %accordion% 请求头 %accordion% %/accordion% %accordion% 请求体【post】 %accordion% %/accordion% 响应报文 %accordion% 响应返回字符串 %accordion% %/accordion% %accordion% 预览返回对象✨ %accordion% %/accordion% 2) http请求 tcp/ip协议 协议 http:// https:// ftp:// 域名 192.168.1.180 ip地址 域名、服务器 端口号 :8080 基本地址 功能地址 /getCountry 三、get和post的区别 1、get请求的参数会在地址栏上显示，而post不会 2、get请求的数据长度有限制（取决于url的长度），而post理论上没有限制 3、get比post更加不安全，数据会直接显示在url上 4、get会发送数据的时候会把请求头、请求数据等一次性发送，而post会先发送请求头然后再发送请求数据 按照restful风格 get一般不发送参数，post发送 请求类型 get 一般用于获取数据，不传参数 在地址栏上面显示 不安全 参数有限制长度✨ post 一般用于获取指定，传参数 在请求体显示 不安全 在发送的时候，会发两次，第一次是发送options，第二次才是真正的post 理论上参数没有限制长度✨ 1) 状态码 状态代码 1xx 正在发送 2xx 发送成功 3xx 重定向 4xx 前端错误 404 地址错误 400 参数错误 5xx 后端错误 2) 请求文本类型 请求文本类型 content-type application/json json类型✨ application/x-www-form-urlencoded 表单类型✨ multipart/form-data 上传类型 %accordion% json数据类型 %accordion% %/accordion% 3) token token密钥 http的请求缺陷，无法判断状态 用途：判断用户是否在登陆 后端生成，发送给前端，前端在每一个请求的请求头都带上这个token，就可以让后端判断该用户是否在登陆状态 token是登陆的时候获取的，其他页面的请求一直带着 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"POST\", \"http://vt.ossjk.com/goods/getDetailGoodsInfo\");//建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 xhr.setRequestHeader(\"jwtToken\", \"f720d5f720d5e261ee0b63a292e261f720d5e261ee0b0bc71fe437c963a292ee0b0bc71fe437c963a292\");//设置token秘钥 let data = { goodsId: \"001\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; %accordion% token秘钥 %accordion% %/accordion% 四、axios [info] 什么是 axios？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 //get请求 axios .get(\"\") .then((res)=>{ console.log(res) }) //post请求 let data = { goodsId:\"b1195296679f482aa7d54d95ac2b4a94\" } axios .post(\"\",data) .then((res)=>{ console.log(res) }) //request请求 axios .request({ url:\"\" }) .then((res)=>{ console.log(res) }) //request请求 let data = { goodsId: \"b1195296679f482aa7d54d95ac2b4a94\", }; axios .request({ url: \"\", method: \"POST\", data, }) .then((res) => { console.log(res); }); //并发请求 function getIndexInfo(){ return axios.get(\"\") } function getCategoryList(){ return axios.get(\"\") } axios .all([getIndexInfo(),getCategoryList()]) .then(axios.spread((res1,res2)=>{ console.log(res1) console.log(res2) })) 易用、简洁且高效的http库 axios中文文档 🚀 %accordion% 安装 %accordion% 安装 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 cdn: %/accordion% [!cogs] GET请求 get是没有参数了 axios .get(\"http://192.168.1.180:8080/getList\") .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //仅参考 axios .get(\"http://192.168.1.180:8080/getList\",{ params:{ id:\"9527\" } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); [!cogs] post请求 post参数了 axios .post(\"http://192.168.1.180:8080/getCountry\", { id: \"001\" }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 %accordion% 执行多个并发请求 %accordion% function API_getList() { return axios.get(\"http://192.168.1.180:8080/getList\") } function API_getCountry(id) { return axios.post(\"http://192.168.1.180:8080/getCountry\", { id: id }) } axios.all([API_getList(), API_getCountry(\"001\")]) .then(axios.spread(function (res1, res2) { console.log(res1); console.log(res2); })) //执行多个并发请求 axios.request({ url: \"http://192.168.1.180:8080/getList\" }).then(function (res) { console.log(res); }) axios.request({ url: \"http://192.168.1.180:8080/getCountry\", method: \"POST\", data: { id: \"001\" } }).then(function (res) { console.log(res); }) %/accordion% 拦截器 %accordion% 拦截器 %accordion% 添加请求拦截器 // 添加请求拦截器 axios.interceptors.request.use( function (config) { // 在发送请求之前做些什么 config.headers.jwtToken = \"9527\"; return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); } ); // 添加响应拦截器 axios.interceptors.response.use( function (response) { // 对响应数据做点什么 if (response.data.code === 200) { alert(\"操作成功\"); } else { alert(\"操作失败\"); } return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); } ); axios.request({ url: \"http://192.168.1.180:8080/getList\" }).then(function (res) { console.log(res); }) axios.request({ url: \"http://192.168.1.180:8080/getCountry\", method: \"POST\", data: { id: \"001\" } }).then(function (res) { console.log(res); }) %/accordion% 取消请求 %accordion% 取消请求【1】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var source = axios.CancelToken.source(); var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: source.token, }) .then(function (res) { console.log(res); }); stopBtn.onclick = function () { source.cancel(\"取消请求1\"); }; %/accordion% %accordion% 取消请求【2】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var CancelToken = axios.CancelToken; var cancel; var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }), }) .then(function (res) { console.log(res); }); stopBtn.onclick = function () { cancel(\"取消请求2\"); }; %/accordion% %accordion% 取消请求【3】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var CancelToken = axios.CancelToken; var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancelFn(c) }), }) .then(function (res) { console.log(res); }); function cancelFn(c) { c(\"取消请求3\") } stopBtn.onclick = cancelFn %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"22jQuery.html":{"url":"22jQuery.html","title":"22jQuery","keywords":"","body":" 一、引入jq 二、使用jq 三、文档就绪 四、$和jQuery 五、解决jq名称冲突 六、选择器 七、jq和js转换 八、jq效果 1、样式操控 2、隐藏/显示、淡入淡出、滑动 3、动画 九、jq html相关 1、文本操控 2、节点操控 3、尺寸 4、jq遍历 5、jq过滤 十、jq ajax 1、创建jq ajax 2、参数 3、案例 4、表单序列化 十一、练习 1、选项卡动画效果 2、jq插件 jQuery [info] JavaScript 函数库 处理浏览器不兼容性并简化 HTML DOM 操作、事件处理、动画和 Ajax。 一、引入jq //1.8以上的版本不再兼容ie8浏览器 \"> 二、使用jq $(\"选择器\") 三、文档就绪 $(function(){}) $(document).ready(function(){}); 四、$和jQuery $完全相等于jQuery 五、解决jq名称冲突 var jq=jQuery.noConflict() 六、选择器 //id选择器 var myElement = $(\"##id01\"); //class var myElements = $(\".intro\"); //标签名 var myElements = $(\"p\"); //当前元素 $(this) 七、jq和js转换 //使用jq选择器获取的后的元素都称为jq对象。 //jq对象只能使用jq的方法，无法使用js原生方法。 //jq转js console.log($(\"##app\")[0].innerText) //js转jq let app = document.querySelector(\"##app\") console.log($(app).html()) 八、jq效果 1、样式操控 //样式化 HTML 元素 myElement.css(\"font-size\",\"35px\"); //添加class myElement.addClass(\"\"); //删除class myElement.removeClass(\"\"); 2、隐藏/显示、淡入淡出、滑动 //隐藏 HTML 元素 myElement.hide(); //显示 HTML 元素 myElement.show(); //切换显示和隐藏 toggle() //淡入 fadeIn() //淡出 fadeOut() //淡入淡出切换 fadeToggle() //向下滑动 slideDown() //向上滑动 slideUp() //滑动切换 slideToggle() 3、动画 //创建动画 $(selector).animate({params},speed,callback); //停止动画 stop() //链式调用 //jq允许我们在相同的元素上运行多条 jQuery 命令 $(\".box\").css({\"width\":\"100px\"}).addClass(\"box2\") 九、jq html相关 1、文本操控 //获取和修改文本 myElement.text() //获取和修改html（包括标签） myElement.html() //获取和修改value值 myElement.val() //获取和修改属性 myElement.attr() //获取和修改该元素的索引值 .index() 2、节点操控 //添加 append() prepend() after() before() //删除被选元素 remove() //删除被选元素的子元素 empty() 3、尺寸 //设置或返回元素的宽度（不包括内边距、边框或外边距） width() height() //返回元素的宽度（包括内边距） innerWidth() innerHeight() //方法返回元素的宽度（包括内边距和边框） outerWidth() outerHeight() 4、jq遍历 //父元素 parents() //子元素 children() //找到被选元素 find() //被选元素的所有同胞元素 siblings() //下一个同胞元素 next() //被选元素的所有跟随的同胞元素 nextAll() //返回介于两个给定参数之间的所有跟随的同胞元素 nextUntil() //下一个同胞元素 prev() 5、jq过滤 //首个元素 first() //最后一个元素 last() //指定索引号的元素 eq() //匹配的元素会被返回 filter() //返回不匹配标准的所有元素 not() 十、jq ajax 1、创建jq ajax $.ajax({}) 2、参数 //发送请求的地址 url(必填) //发送类型，默认使用get type //请求成功后的回调函数 success //请求失败时调用此函数 error //发送到服务器的数据 data //设置请求超时时间（毫秒）。此设置将覆盖全局设置。 timeout //这个对象用于设置 Ajax 相关回调函数的上下文。(修改this指针) context $.ajax({ url: \"test.html\", context: document.body, success: function(){ $(this).addClass(\"done\"); }}); //发送信息至服务器时内容编码类型(默认值: \"application/x-www-form-urlencoded\") contentType //发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头 beforeSend(XHR) 3、案例 //发送登陆请求 var data = { \"name\":\"小明123\", \"pwd\":\"123456\" } $.ajax({ url:\"\", type:\"POST\", contentType:\"application/json\", data:JSON.stringify(data), success:function(res){ console.log(res) } }) //带token(令牌)的请求 $.ajax({ url: \"\", type: \"POST\", beforeSend: function(xhr) { xhr.setRequestHeader(\"token\", \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJhMjczYTMwM2QxZGI0ODRhODIyZGZjMWE2NzM2MGM3MiIsImlhdCI6MTU2Njg5OTQwNywic3ViIjoi5L2V5ZiJ5L-KMTIzIiwiaWQiOiI1MDk0MmJkMDk4MzI0MzM3YWE4MGJhZjk4MmRjYzI4ZiIsImV4cCI6MTU2Njg5OTc2N30.cuJkCUoHT5oCpyrlRW6JFjQV_q5URiQ2txoM7dqQSJQ\" ) }, success: function(res) { console.log(res) } }) 4、表单序列化 //将表单内容序列化成一个字符串 serialize() //将页面表单序列化成一个JSON结构的对象。注意不是JSON字符串 serializeArray() 十一、练习 1、选项卡动画效果 标题一 标题二 标题三 123 456 789 .tab{ width: 500px; height: 500px; border: 1px solid; } .tab-title{ width: 100%; height: 100px; border-bottom: 1px solid; } .tab-title div{ width: 100px; height: 100px; float: left; border-right: 1px solid; text-align: center; line-height: 100px; } .tab-title .on{ background:pink; } .tab-content div{ display: none; } .tab-content .on{ display: block; } $(\".tab .tab-title div\").click(function(){ $(this).addClass(\"on\").siblings().removeClass(\"on\") let idx = $(this).index() $(\".tab .tab-content div\").eq(idx).addClass(\"on\").siblings().removeClass(\"on\") }) 2、jq插件 //index.html Document .tab{ width: 500px; height: 500px; border: 1px solid; } .tab-title{ width: 100%; height: 100px; border-bottom: 1px solid; } .tab-title div{ width: 100px; height: 100px; float: left; border-right: 1px solid; text-align: center; line-height: 100px; } .tab-title .on{ background:pink; } .tab-content div{ display: none; } .tab-content .on{ display: block; } 标题一 标题二 标题三 123 456 789 \"> $(\".tab\").slides({ \"tab\":\".tab\", \"tabTitle\":\".tab-title\", \"tabContent\":\".tab-content\", \"autoPlay\":true, \"delaytime\":2000 }) //tab.js !function($){ $.fn.extend({ \"slides\":function(options){ let args = $.extend({ \"tab\":\".tab\", \"tabTitle\":\".tab-title\", \"tabContent\":\".tab-content\", \"autoPlay\":false, \"delaytime\":1000 },options) let that = $(`${args.tab}`)//tab let title = $(`${args.tabTitle}`).find(\"div\")//title let content = $(`${args.tabContent}`).find(\"div\")//content let idx = 0 function show(idx){ title.eq(idx).addClass(\"on\").siblings().removeClass(\"on\") content.eq(idx).addClass(\"on\").siblings().removeClass(\"on\") } function autoPlay(){ setInterval(function(){ idx>=title.length-1 ? idx=0 : idx++ show(idx) },args.delaytime) } title.click(function(){ idx = $(this).index() show(idx) }) if(args.autoPlay){ autoPlay() } } }) }(jQuery) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"23函数进阶.html":{"url":"23函数进阶.html","title":"23函数进阶","keywords":"","body":" 一、变量提升给函数带来的问题 二、修改 this 指针 call、apply、bind 三、高阶函数 四、函数柯里化 1、创建函数柯里化 2、参数递归 五、节流函数和防抖函数 1、节流函数 2、防抖函数 3、优化版的防抖函数 函数进阶 一、变量提升给函数带来的问题 //报错，fn不是一个函数， //原因是var变量提升在全局作用域添加了一个fn为undefined， //所以undefined无法执行 fn(); var fn = function () { console.log(123); }; 二、修改 this 指针 //把函数fn的指针修改为指向对象obj function fn(num) { console.log(this); console.log(num); } let obj = { name: \"小明\", }; fn.call(obj, 123); call、apply、bind [warning]call\\apply\\bind有什么区别？ 面试题 1、call和apply是返回值，bind是返回函数 2、call和bind是选项式参数、apply是数组参数 var obj = { name:\"小明\" } function fn(a,b,c){ console.log(this) console.log(a) console.log(b) console.log(c) } // fn.call(obj,1,2,3) // fn.apply(obj,[1,2,3]) var f = fn.bind(obj,1,2,3) f() //把对象obj里面的fn2函数的指针修改为指向函数fn的this function fn(){ obj.fn2.call(this) } let obj = { fn2:function(){ console.log(this) } } fn() //案例 var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = function(){//虽然函数外层是obj2的作用域，但是因为函数默认指向了window，所以这里指的是window console.log(this.name)//小明 } a() } } } obj.obj2.fn() var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = ()=>{//箭头函数让this绑定在当前作用域下，无法修改this指针 console.log(this.name)//小绿 } a() } } } obj.obj2.fn() [!cogs] %accordion% 模块标题 %accordion% var obj = { name: \"娜美\" } function fn(a, b, c) { console.log(this); console.log(a); console.log(b); console.log(c); } fn.call(obj, 1, 2, 3) //返回值——是选择式参数 // fn.apply(obj,[1,2,3])//返回值——是选择式参数 // var f=fn.bind(obj,1,2,3)//返回函数——是数组参数 // f() %/accordion% %accordion% 模块标题 %accordion% var obj = { name: \"娜美\", fn1: function () { fn2.call(this) //修改他指针 }, } function fn2() { console.log(this); } obj.fn1() %/accordion% %accordion% 练习 %accordion% var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = function () { // console.log(this); console.log(this.name);//娜美 } a() }, }, } obj.obj2.fn() %/accordion% %accordion% 函数tkis %accordion% var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = () => { console.log(this.name); //大和 } a() }, }, } obj.obj2.fn() var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = () => { console.log(this.name); //大和 } a.call() //就该这里 }, }, } obj.obj2.fn() %/accordion% 三、高阶函数 [info] 高阶函数 就是使函数抽象化，抽象就是隐藏更具体的实现细节，从更高的层次看待我们要解决的问题 // 给所有的数组添加一个自定义迭代方法 let arr = [1, 2, 3, 4, 5]; // arr.forEach(function(item,i){ // console.log(item) // }) Array.prototype.myForEach = function (f) { let arr = this; for (let i = 0; i [!cogs] %accordion% 高阶函数 %accordion% [warning] 函数myForEach 给所有的数组都添加一个myForEach的方法 Array.prototype.myForEach = function (f) { var arr = this for (var i = 0; i %/accordion% 四、函数柯里化 [info] 柯里化 函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。 目的是复用参数。 1、创建函数柯里化 function fn(a, b) { return a + b; } fn(1, 2); fn(1, 3); //复用参数 function fn(a) { return function (b) { console.log(a + b); }; } let f = fn(1); f(2); f(3); 2、参数递归 //参数固定 function curry(f, args = []) { //柯里化函数 return function () { let arr = [...args, ...arguments]; if (arr.length [!cogs] %accordion% 函数柯里化🚀 %accordion% 复用参数 function fn(a) { return function (b) { return a + b } } var f = fn(1)//固定值 console.log(f(2));//3 console.log(f(3));//4 %/accordion% %accordion% 参数固定 %accordion% function curry(fn,arr=[]){ return function(){ var arg=[...arguments] var len=fn.length var allArr=[...arg,...arr] if(allArr.length %/accordion% %accordion% 参数不固定 %accordion% function curry(fn, arg = []) { return function () { var allArr = [...arg, ...arguments]; if (arguments.length) { return curry(fn, allArr); } else { return fn(...allArr); } }; } var handler = curry(function () { var arr = [...arguments]; return arr.reduce(function (x, y) { return x + y; }); }); console.log(handler(1)(2)(3)(4)); %/accordion% 五、节流函数和防抖函数 1、节流函数 [info] 节流函数 在某段时间内，不管触发了多少次回调，只认第一次触发，无视后面次数产生的触发，并在计时结束时给予响应。 var div = document.querySelector(\"div\"); function throttle(fn, time) { //节流函数 var last = 0; return function () { var now = new Date().getTime(); if (now - last >= time) { last = now; fn.apply(this, arguments); } }; } var clickHandler = throttle(function () { //具体逻辑 console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; [!cogs] %accordion% 节点函数🚀 %accordion% 第一次触发，就执行，如再继续触发下去就等待3秒钟才执行。 按钮 var btn = document.querySelector(\".btn\"); function throttle(fn, delayTime) { var endTime = 0; return function () { var nowTime = +new Date(); if (nowTime - endTime > delayTime) { fn(); endTime = nowTime; } }; } var handler = throttle(function () { console.log(123); }, 3000); btn.addEventListener(\"click\", handler); %/accordion% 2、防抖函数 [info] 防抖函数 在某段时间内，每次触发都会重新计时，直到最后一次触发超过了限定的时间。 var div = document.querySelector(\"div\"); function debounce(fn, time) { var timer; return function () { if (timer) { clearTimeout(timer); } timer = setTimeout(function () { fn.apply(this, arguments); }, time); }; } var clickHandler = debounce(function () { console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; %accordion% 防抖函数🚀 %accordion% 第一次触发等待3秒才执行，如频繁触发就从0开始直到你不按为止，待3秒才执行。 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer return function () { if (timer) { clearTimeout(timer) } timer = setTimeout(function () { fn() }, delayTime) } } var handler = deBounce(function () { console.log(123); }, 3000) btn.addEventListener(\"click\", handler) %/accordion% 3、优化版的防抖函数 [info] 优化版 防抖函数的问题，频繁的延迟会导致用户迟迟得不到响应。优化版的防抖函数本质上还是节流函数。 var div = document.querySelector(\"div\"); function betterDebounce(fn, time) { var timer; var last = 0; return function () { var now = +new Date(); if (now - last %accordion% 优化版的防抖函数🚀 %accordion% 第一次触发就执行，如频繁触发就从0开始直到你不按为止，才执行 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer var endTime = 0 return function () { var nowTime = +new Date() if (nowTime - endTime %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"24面向对象.html":{"url":"24面向对象.html","title":"24面向对象","keywords":"","body":" 一、面向对象的优势和特性 二、类的创建方式 1、工厂模式，生产出来的所有实例化对象都是一样 2、实例化模式，复用性差，没有共性 3、基于原型的混合模式，同时具有共性和特性 三、实例化对象、构造函数、原型 四、原型链 五、对象的方法 六、堆和栈 1）浅克隆和深克隆 浅克隆,只克隆对象的第一层属性 深克隆,克隆对象的所有层级的属性 2）类的继承 面向对象 [info] 面向对象(oop) 是一种软件开发方法，一种编程范式。面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。 一、面向对象的优势和特性 [!COMMENT] 优势 1、方便 2、复用性高 3、高内聚低耦合 4、代码冗余低 特点 1、封装。也就是把客观事物封装成抽象的类。 2、继承。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 3、多态。允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 %accordion% 历史解说🚀 %accordion% c 面向过程 过程，难以理解 c++ 面向对象 对象，容易理解，维护性高 ecma es6 (2015) JavaScript： js 不是面向对象语言，面向原型语言 prototype es6 面向对象 class %/accordion% %accordion% 三种法🚀 %accordion% // 1、函数 function person(){//函数 } person() // 2、构造函数、类 function Person(){//以前：构造函数 //现在：类 } new Person() // 3、类、构造函数（es6） class Person{//类 constructor(){//构造函数 } } 简单定义一个函数 // function person() {//函数 // this.name = \"小明\"// 给window加 // } function person() {//以前：构造函数 //现在：类 this.name = \"小明\" } var p = new person()//对象 console.log(p); //person {name: \"小明\"} %/accordion% 二、类的创建方式 1、工厂模式，生产出来的所有实例化对象都是一样 function Car(){ this.name = \"奔驰\" this.color = \"black\" } let a = new Car() let b = new Car() console.log(a) console.log(b) %accordion% 克隆工厂模式🚀 %accordion% function person() {//构造函数/类 this.name = \"小明\" } var p1 = new person()//对象 console.log(p1); //person {name: \"小明\"} var p2 = new person()//对象 console.log(p2); //person {name: \"小明\"} %/accordion% 2、实例化模式，复用性差，没有共性 function Car(name,color){//实例化模式，复用性差 this.name = name this.color = color } let a = new Car(\"奔驰\",\"黑色\") let b = new Car(\"宝马\",\"蓝色\") console.log(a) console.log(b) %accordion% 实例化模式🚀 %accordion% function person(name) {//构造函数/类 this.name = name } var p1 = new person(\"小明\")//对象 console.log(p1); //person {name: \"小明\"} var p2 = new person(\"小红\")//对象 console.log(p2); //person {name: \"小红\"} %/accordion% 3、基于原型的混合模式，同时具有共性和特性 function Car(name){ this.name = name } Car.prototype.color = \"黑色\" let a = new Car(\"奔驰\") let b = new Car(\"宝马\") console.log(a) console.log(b) %accordion% 混合模式，同时具有共性和特性🚀 %accordion% function person(name, age, sex) {//构造函数/类 this.name = name this.age = age this.sex = sex } person.prototype.country = \"中国\"//共性(原型去添加) var p1 = new person(\"小明\", 18, \"男\")//特性 console.log(p1); //person {name: \"小明\", age: 18, sex: \"男\"} var p2 = new person(\"小红\", 23, \"女\")//特性 console.log(p2); //person {name: \"小红\", age: 18, sex: \"男\"} 这种仅参考 function person(name, age, sex, country) {//构造函数/类 this.name = name this.age = age this.sex = sex this.country = country } var p1 = new person(\"小明\", 18, \"男\", \"中国\")//对象 console.log(p1); //person {name: \"小明\", age: 18, sex: \"男\", country: \"中国\"} var p2 = new person(\"小红\", 23, \"女\", \"中国\")//对象 console.log(p2); //person {name: \"小红\", age: 18, sex: \"男\", country: \"中国\"} %/accordion% 三、实例化对象、构造函数、原型 [!COMMENT] For !COMMENT 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象。 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象。 所有引用类型的__proto__属性指向它构造函数的prototype。 function Car(){//构造函数 this.name = \"奔驰\" this.color = \"black\" } let a = new Car() console.log(a)//实例化对象 console.log(a.__proto__)//实例化对象a的原型 console.log(Car.prototype)//实例化对象a的原型 console.log(a.__proto__ === Car.prototype)//true 四、原型链 [!NOTE] 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 function Car(){//构造函数 this.name = \"奔驰\" this.color = \"black\" } let a = new Car() console.log(a.__proto__)//实例化对象a的原型。即Car.prototype console.log(a.__proto__.__proto__)//对象Object的原型。即Object.prototype console.log(a.__proto__.__proto__.__proto__)//null 图片块 类\\\\构造函数 1、prototype -> 访问原型 2、__proto__ -> 指针，访问构造这个类的原型 原型 1、prototype -> 访问原型 2、__proto__ -> 指针，访问构造这个原型的原型 3、constructor -> 访问类\\\\构造函数 实例化对象 1、__proto__ -> 指针，访问构造这个实例化对象的原型 2、constructor -> 访问类\\\\构造函数 [!cogs] %accordion% 练习 %accordion% function Person(name) {//类、构造函数 this.name = name//实例属性 } var p = new Person(\"小明\") // console.log(Person.prototype); // console.log(Person.__proto__.constructor);//指针，指向构造这个类的原型 // console.log(Person.__proto__.__proto__); // console.log(person.__proto__.__proto__.__proto__);//null Person.__proto__.__proto__.constructor.prototype.eyes = 3 Person.prototype.eyes = 3 console.log(p.eyes);//3 %/accordion% 五、对象的方法 //返回指定对象的原型，用来代替__proto__ Object.getPrototypeOf(obj) //在对象自身查找属性而不到原型上查找 hasOwnProperty() //判断一个对象是否是某个实例的原型对象 isPrototypeOf //判断一个对象是否是一个类的实例 instanceof //根据__proto__来创建一个新对象 Object.create() //用于将所有可枚举属性的值从一个或多个源对象复制到目标对象 Object.assign() //案例 function Car(name){ this.name = name } Car.prototype.color = \"黑色\"//原型属性（共性） let a = new Car(\"奔驰\") console.log(a.hasOwnProperty(\"name\"))//true console.log(a.__proto__.isPrototypeOf(a))//true console.log(a instanceof Car)//true let b = Object.create(a.__proto__)//创建一个基于原型的新对象 console.log(b) let obj = {name:\"小明\"} let obj2 = {name:\"小红\"} console.log(Object.assign(obj,obj2)) 六、堆和栈 //堆 存储引用类型数据object(函数，数组等都是) //栈 存储普通类型数据number,string,boolean,undefined,null //栈是直接赋值数据，堆是赋值引用地址 //栈类型数据 var a = \"123\" var b = a b = \"456\" console.log(a)//123 console.log(b)//456 //堆类型数据 var a = {\"name\":\"小明\"} var b = a b.name = \"小红\" console.log(a)//{name: \"小红\"} console.log(b)//{name: \"小红\"} %accordion% 堆和栈的区别 %accordion% 堆和栈 栈是直接赋值数据：速度快 堆是赋值引用地址：速度慢 堆： 粘贴 文件a（10mb） 文件b（10,mb） 栈： 粘贴快捷方式 文件a（10mb） 文件b（5kb） 直接赋值 【栈】 var a = 1 var b = a b = 2 console.log(a); //1 console.log(b); //2 赋值的是引用地址，CPU地址 对象 【堆】 var a = { name: \"小明\" } var b = a; b.name = \"小红\" console.log(a); //小红 console.log(b); //小红 %/accordion% 1）浅克隆和深克隆 浅克隆,只克隆对象的第一层属性 var obj = {name:\"小明\"} var obj2 = Object.assign({},obj) obj2.name = \"小红\" console.log(obj) //{name: \"小明\"} console.log(obj2) //{name: \"小红\"} %accordion% 浅克隆——更改值另一个不受影响 %accordion% var a = { name: \"小明1\", obj: { name: \"小明2\" } } var b = Object.assign({}, a) b.obj.name = \"小红\" console.log(a); console.log(b); %/accordion% 深克隆,克隆对象的所有层级的属性 [!COMMENT] 深克隆有三种方法 1、自定义深克隆——麻烦 2、JSON.parse(JSON.stringify())——缺陷 3、jq方法 $.extend(true,{},obj)——引用函数库 [!cogs] %accordion% 简单深克隆 %accordion% var a = { name: \"小明1\", obj: { name: \"小明2\" } } var x = Object.assign({}, a) var y = Object.assign({}, a.obj) x.obj = y x.obj.name = \"小红2\" console.log(x); console.log(a); %/accordion% %accordion% 1、自定义深克隆 %accordion% function deepClone(obj){ var x = {} for(key in obj){ if(typeof obj[key] === \"object\"){ x[key] = deepClone(obj[key]) }else{ x = Object.assign(x,obj) } } return x } var b = deepClone(a) b.obj.name = \"小红2\" console.log(a)//{name: \"小明1\",obj: {name: '小明2'}} console.log(b)//{name: \"小明1\",obj: {name: '小红2'}} %/accordion% %accordion% 2、JSON.parse(JSON.stringify()) %accordion% 工作中用得最多了 缺陷里面有——构造涵数、正则表达式 都会有问题 var a = { name: \"小明1\", obj: { name: \"小明2\" } } var b = JSON.parse(JSON.stringify(a)) b.obj.name = \"小红\" console.log(a); console.log(b); %/accordion% %accordion% 3、jq方法 $.extend(true,{},obj) 引用函数库 %accordion% jquery var a = { name: \"小明1\", obj: { name: \"小明2\" }, reg: /hello/ } var b = $.extend(true, {}, a) b.obj.name = \"小红2\" console.log(a); console.log(b); %/accordion% 2）类的继承 es5 //es5 function Person(){ this.name = \"小明\" } Person.prototype.age = 18 var p = new Person() function Student(){ Person.call(this) } Student.prototype = Person.prototype var s = new Student() console.log(s.age) es6 ——方便 class Person{ constructor(name){ this.name = name } } var p = new Person(\"小明\") class Student extends Person{ constructor(name){ super(name) } } var s = new Student(\"小红\") console.log(s) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"repair.html":{"url":"repair.html","title":"npm包管理系统","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"es6.html":{"url":"es6.html","title":"Es6","keywords":"","body":"ES6 [success] ecmaScript6（es6/es2015） 是一种由Ecma国际(欧洲计算机制造商协会)通过ECMA-262标准化的脚本程序设计语言(2015年发布) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 13:57:18 "},"01变量-es6.html":{"url":"01变量-es6.html","title":"01变量","keywords":"","body":" 一、变量let 1、没声明变量 2、常见报错(es5—es6) 1） 2） 3） 4） 5） 3、块级作用域 变量 一、变量let //1)不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用 console.log(a) let a = 1//报错 //2)同一作用域的同一个变量不能够重复声明，避免我们重复声明变量 let a = 'hello world' let a = 'hello world'//报错 //3)let声明的变量不会绑定到window let a = 'hello swr' console.log(window.a)//undefined //4)let和代码块{}结合使用会形成块级作用域 { let str = \"hello\" } console.log(str)//hello //5)暂时性死区 //在代码块内，使用let命令声明变量之前，该变量都是不可用的 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } [!cogs] %accordion% 历史解说 %accordion% JavaScript JScript ecma(计算机标准组织) es5 ———— （2015以下都是es5） es6 ———— (es2015) es7 es8 es9 es10 es11（最新） %/accordion% 1、没声明变量 不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用 //es5 console.log(a);//安笛梵undefined var a = 1; //es6 console.log(a); //报错 let a = 1; 2、常见报错(es5—es6) 1） //es5 var a = 1; function fn() { console.log(a);//undefined var a = 2; } fn(); //es6 let a = 1 function fn() { console.log(a); //报错 let a = 2 } fn() fn()//var fn()这个是变量提升 es6就会报错 es5就undefined var fn = function () { console.log(123); } 2） //es5 var a = 1 var a = 2 console.log(a);//这种是2 //es6 let a = 1 let a = 2 console.log(a);//报错 //es6 let a = 1 a = 2 console.log(a);//这种是2 3） //es5 var a = 1 console.log(window.a);//这种是1 //es6 let a = 1 console.log(window.a); //undefined 4） //es5 for (var i = 1; i 5） //es5 function fn() { a = 1 console.log(a); //1 } fn() //es6 function fn() { a = 1 console.log(a);//报错 let a } fn() 3、块级作用域 [info] 块级{} 花括号都是块级{} let和代码块{}结合使用会形成块级作用域 //es5 { var a = 1 console.log(a);//1 } { var a = 1 console.log(window.a);//1 } //es6 { let a = 1 console.log(a);//1 } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 14:00:13 "},"02常量-es6.html":{"url":"02常量-es6.html","title":"02常量","keywords":"","body":"常量 //常量是固定的量，一般用于存地址等信息 const a = 1 const baseUrl = \"www.baidu.com\" [!cogs] //es5 var BASE_URL = \"www.baidu.com\" BASE_URL = \"www.sina.com\" console.log(BASE_URL); //www.sina.com //es6 const BASE_URL = \"www.baidu.com\" BASE_URL = \"www.sina.com\" console.log(BASE_URL); //报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 13:05:30 "},"03解构赋值-es6.html":{"url":"03解构赋值-es6.html","title":"03解构赋值","keywords":"","body":" 一、使用解构赋值 二、数组解构赋值 三、对象解构 解构赋值 一、使用解构赋值 function fn(){ let a = 1 let b = 2 return { a,b } } //没有解构赋值 let obj = fn() console.log(obj.a) console.log(obj.b) //使用了解构赋值 let {a,b} = fn() console.log(a) console.log(b) //等同于下面的代码，在es6里面，对象的key和value相同时，可以省略后面的冒号和value let {a:a,b:b} = fn() console.log(a) console.log(b) //结构赋值命名 let {a:x,b:y} = fn() console.log(x) console.log(y) [!cogs] %accordion% es5与es6写法 %accordion% //es5 var obj = { name: \"张三\", age: 18 } console.log(obj.name); //张三 console.log(obj.age); //18 //es6 let { name, age } = { name: \"张三\", age: 18 }; console.log(name); //张三 console.log(age); //18 %/accordion% 二、数组解构赋值 //数组解构 let [a,b,c] = [1,2,3,4,5] console.log(a) console.log(b) console.log(c) //默认值 let [a=1,b,c] = [\"x\",2,3,4,5] console.log(a) console.log(b) console.log(c) //克隆 let a = [1,2,3,4,5] // let b = Object.assign([],a) 浅克隆 // let b = JSON.parse(JSON.stringify(a)) 深克隆 let b = [...a]//es6 b.push(6) console.log(a)//[1,2,3,4,5] console.log(b)//[1,2,3,4,5,6] let [b,c,d] = [...a]//es6 console.log(b)//1 console.log(c)//2 console.log(d)//3 [!cogs] %accordion% 数组解构赋值 %accordion% let [a, b, c] = [\"张三\", \"李四\", \"老王\"] console.log(a); //张三 console.log(b); //李四 console.log(c); //老王 %/accordion% %accordion% 默认 %accordion% let [a, b, c = \"张三\"] = [\"李四\", \"老王\", \"赵四\"] console.log(a); //李四 console.log(b); //老王 console.log(c); //赵四 %/accordion% %accordion% 浅克隆 %accordion% let a = [1, 2, 3] let b = [...a] console.log(b);//[1, 2, 3] let a = [1, 2, 3] let b = [...a] b[0] = 'x' console.log(b);//[\"x\", 2, 3] let a = [ { name: \"张三\", obj: { name: \"李四\" } } ] let b = [...a] b[0].obj.name = \"老王\" console.log(a);//{name: \"张三\", obj: {…}} console.log(b);//{name: \"张三\", obj: {…}} let a = [1, 2, 3] let b = a b[0] = \"x\" console.log(a);//[\"x\", 2, 3] console.log(b);//[\"x\", 2, 3] let a = [1, 2, 3] let b = [...a] b[0] = \"x\" console.log(a); //[1, 2, 3] console.log(b); //[\"x\", 2, 3] %/accordion% 三、对象解构 //对象解构 let {name,age} = {name:\"swr\",age:28} console.log(name) // 'swr' console.log(age) // 28 //对象解构-命名 let { name:Name,age } = { name:'swr',age:28 } console.log(Name) // 'swr' console.log(age) // 28 //默认值 let {name=\"swr\",age} = {age:28} console.log(name) // 'swr' console.log(age) // 28 //解构函数参数 function fn({name,age}){ console.log(name) console.log(age) } fn({name:\"小明\",age:18}) //数组对象解构 let [,{name}] = [{name:'小明',age:18},{name:'小红',age:19}] console.log(name)//小红 [!cogs] %accordion% 对象解构%accordion% //对象解构-命名 let { name: a } = { name: \"张三\" } console.log(a); //张三 let { name, age = 18 } = { name: \"张三\", age: 19 } console.log(age); //19 %/accordion% %accordion% 解构函数参数 %accordion% function fn({ name, age }) { console.log(name); //张三 console.log(age); //18 } fn({ name: \"张三\", age: 18 }) %/accordion% %accordion% 数组对象解构 %accordion% //打印第一个 let [{ name, age }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(name)//张三 console.log(age)//18 //打印第二个 let [, { name, age }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(name) //李四 console.log(age) //19 //打印二个 let [{ name: aName, age: aAge }, { name: bName, age: bAge }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(aName) //张三 console.log(aAge) //18 console.log(bName) //李四 console.log(bAge) //19 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 23:45:15 "},"04字符串拓展-es6.html":{"url":"04字符串拓展-es6.html","title":"04字符串拓展","keywords":"","body":"字符串拓展 //for of 字符串遍历 let str = \"hello world\" for(s of str){ console.log(s) } //includes 返回布尔值，表示是否找到了参数字符串 let str = \"hello world\" console.log(str.includes(\"hello\"))//true //repeat 方法返回一个新字符串，表示将原字符串重复n次 let str = \"hello\" console.log(str.repeat(2))//hellohello //模版字符串 let str = `hello world` let str = `飞流直 下三千尺` console.log(str) let s = \"world\" let str = \"hello\"+s console.log(str) let s = \"world\" let str = `hello ${s}` console.log(str) [!cogs] %accordion% for of 字符串遍历 %accordion% let str = \"hello world\" for (idx of str) { console.log(idx); } %/accordion% 模版字符串 let str = `hello world` console.log(str); //答案： //hello //world let a = \"hello\" let b = \"world\" console.log(`${a}${b}`); //helloworld Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 20:37:26 "},"05数字拓展-es6.html":{"url":"05数字拓展-es6.html","title":"05数字拓展","keywords":"","body":"数字拓展 //isFinite() 检查一个数值是否为有限的 Number.isFinite(15); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false //isNaN() 判断一个值是否为非数字 let str = \"hello\" console.log(isNaN(Number(str)))//true //parseInt() 把字符串变为正整数 Number.parseInt('12.34') //parseFloat() 把字符串变为浮点数 Number.parseFloat('12.34') //isInteger() 用来判断一个值是否为整数 //Math.sign() 用来判断一个数到底是正数、负数、还是零 console.log(Math.sign(5))//1，正数 console.log(Math.sign(-5))//-1，负数 console.log(Math.sign(0))//0，零 [!cogs] %accordion% 用来判断一个值是否为整数 %accordion% let num = 1.5 console.log(Number.isInteger(num)); //false %/accordion% %accordion% js的浮点数缺陷 %accordion% let num1 = 0.1 let num2 = 0.2 let num3 = (num1 + num2).toFixed(1) console.log(Number(num3)); //0.3 %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 20:41:26 "},"06数组拓展-es6.html":{"url":"06数组拓展-es6.html","title":"06数组拓展","keywords":"","body":"数组拓展 //Array.from() 把类数组转化成数组 function fn(){ console.log(Array.from(arguments)) } fn(1,2,3) //Array.of 将一组值，转换为数组 console.log(Array.of(3, 11, 8)) // [3,11,8] //find() 找出第一个符合条件的数组成员 let arr = [1,2,3,4,5] let newArr = arr.find(function(item){ return item % 2 === 0 }) console.log(newArr)//2 //findIndex() 找出第一个符合条件的数组成员的索引值 let arr = [1,2,3,4,5] let newArr = arr.findIndex(function(item){ return item % 2 === 0 }) console.log(newArr)//1 //fill() 填充数组 console.log(['a', 'b', 'c'].fill(7))//[7, 7, 7] console.log([,,,].fill(6))//[6,6,6] //flat() 数组扁平化 let arr = [['name', '小明'], ['age', 18], ['sex', '男']] console.log(arr.flat(1))//[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] let arr = [1,2,[3,4,[5,6]]] console.log(arr.flat(Infinity))//永远变成1维数组 [!cogs] %accordion% 把类数组转化成数组 %accordion% function fn() { console.log([...arguments]); //[1, 2, 3] // console.log(Array.from(arguments)); //[1, 2, 3] } fn(1, 2, 3) //Array.of 将一组值，转换为数组 console.log(Array.of(3, 11, 8)) // [3,11,8] //find() 找出第一个符合条件的数组成员 let arr = [1, 2, 3, 4, 5] let newArr = arr.find(function (item) { return item % 2 === 0 }) console.log(newArr)//2 %/accordion% 数组扁平化✨ //flat() 数组扁平化 let arr = [ ['name', '小明'], ['age', 18], ['sex', '男'] ] console.log(arr.flat(1)) //[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] //flat() 数组扁平化 //Infinity永远都是一维 let arr = [ [1, 2, [3, 4, [5, 6]]] ] console.log(arr.flat(Infinity)) //[1, 2, 3, 4, 5, 6] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 20:47:12 "},"07函数拓展-es6.html":{"url":"07函数拓展-es6.html","title":"07函数拓展","keywords":"","body":" 箭头函数 1、单行的时候可以不加大括号 2、单行使用的时候可以直接返回值，不需要加return 3、无参数写法 4、绑定this指针 5、无法当成构造函数使用 6、箭头函数没有arguments 函数拓展 //形参默认值 function fn(a=1){ console.log(a) } fn(2) ///与解构赋值一起用 function fn({name}){ console.log(name) } fn({name:\"小明\"}) //和扩展预算符一起使用 function fn(a,...b){ console.log(a)//1 console.log(b)//[2, 3, 4, 5] } fn(1,2,3,4,5) %accordion% 练习 %accordion% //形参默认值 function fn(a,b=1){ console.log(a+b) } fn(1) //2 %/accordion% 箭头函数 1、单行的时候可以不加大括号 let fn = ()=> console.log(\"hello world\") console.log() 2、单行使用的时候可以直接返回值，不需要加return let fn = ()=> \"hello world\" console.log(fn()) 3、无参数写法 //没有参数的时候可以使用括号也可以使用下划线 let fn = _ => \"hello world\" console.log(fn()) %accordion% 练习 %accordion% //有参数 let fn = () => 1 console.log(fn()); //1 // 无参数 let fn = _ => 1 console.log(fn());//1 %/accordion% 4、绑定this指针 //使用箭头函数的时候，无法修改this指针 function fn(){ console.log(this)//obj } let fn = ()=>{ console.log(this)//window } let obj = { name:\"小明\" } fn.call(obj) %accordion% 练习 %accordion% let obj = { name: \"张三\" } function fn() { console.log(this); } fn.call(obj)//{name: \"张三\"} let obj = { name: \"张三\" } let fn = () => { console.log(this); //Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …} } fn.call(obj) %/accordion% 5、无法当成构造函数使用 let Person = ()=>{ } new Person()//报错 6、箭头函数没有arguments let Person = ()=>{ console.log(arguments)//报错 } Person() %accordion% 练习 %accordion% // 错误法 let fn = (name) => { this.name = name } let f = new fn(\"张三\") console.log(f); let fn = () => { console.log(arguments); } fn(1, 2, 3) %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 22:50:15 "},"08对象拓展-es6.html":{"url":"08对象拓展-es6.html","title":"08对象拓展","keywords":"","body":"对象拓展 //Object.is() 判断两个值是否相等 console.log(Object.is('foo', 'foo'))//true console.log(Object.is({}, {}))//false //Object.assign() 用于对象的合并 let obj = {name:\"小明\"} let obj2 = {age:18} console.log(Object.assign(obj,obj2))//{name:\"小明\",age:18} let obj = {name:\"小明\"} let obj2 = {name:\"小红\"} console.log(Object.assign(obj,obj2))//小红 //对键名的遍历和对键名的遍历 let obj = {name:\"小明\",age:18,sex:\"男\"} console.log(Object.keys(obj))//['name', 'age', 'sex'] console.log(Object.values(obj))//['小明', 18, '男'] //entries() 对键值对的遍历 let obj = {name:\"小明\",age:18,sex:\"男\"} console.log(Object.keys(obj))//['name', 'age', 'sex'] console.log(Object.values(obj))//['name', 'age', 'sex'] console.log(Object.entries(obj))//[['name', '小明'], ['age', 18], ['sex', '男']] let newArr = Object.entries(obj) console.log(newArr) console.log(newArr.flat(1))//[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] [!cogs] %accordion% Object.is() 判断两个值是否相等 %accordion% console.log(Object.is(\"hello\",\"world\")); //true let str=\"hello\" let str2=\"hello\" console.log(str==str2); //true // 对象不能同时出现两个不然会报错 let str ={name:\"张三\"} let str2 ={name:\"张三\"} console.log(str==str2); //false %/accordion% %accordion% Object.assign() 用于对象的合并🚀 %accordion% //Object.assign() 用于对象的合并 ✨ let obj = { name: \"张三\" } let obj2 = { age: 18 } console.log(Object.assign(obj, obj2)); //{ name: \"张三\", age: 18 } console.log({ ...obj, ...obj2 }); //{ name: \"张三\", age: 18 } %/accordion% %accordion% 对键名的遍历和对键名的遍历 %accordion% let obj = { name: \"张三\", age: 18 } let arr = Object.keys(obj) console.log(arr);//[\"name\", \"age\"] let arr = Object.values(obj) console.log(arr);//[\"张三\", 18] let arr = Object.entries(obj) console.log(arr.flat(1)); //[\"name\", \"张三\", \"age\", 18] %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 23:03:08 "},"09类拓展-es6.html":{"url":"09类拓展-es6.html","title":"09类拓展","keywords":"","body":" 一、创建类 二、类继承 类拓展 一、创建类 class Person{ constructor(name) {//构造器 this.name = name//实例化属性 } age = 18//实例化属性 static hobby = \"打游戏\"//静态属性 } Person.prototype.sex = \"男\"//原型属性 let p = new Person(\"小明\") Person.hobby//打游戏 [!cogs] %accordion% 这种是活了 %accordion% class Person {//类 constructor(name, age) {//构造函数 this.name = name//实例属性 this.age = age } } let p = new Person(\"张三\", 18) console.log(p); //Person {name: \"张三\", age: 18} %/accordion% %accordion% 这种age已经写死了 %accordion% class Person {//类 constructor(name) {//构造函数 this.name = name//实例属性 } age = 18//实例化属性 } let p = new Person(\"张三\") console.log(p); //Person {age: 18, name: \"张三\"} %/accordion% %accordion% 语法糖 %accordion% class Person {//类 constructor(name) {//构造函数 ——对象上调用 this.name = name//实例属性 ——对象上调用 } age = 18//实例化属性 static hobby = \"打游戏\"//静态属性，——在类上调用 } Person.prototype.sex = \"男\"//原型属性 ——对象上调用 let p = new Person(\"张三\") console.log(p); //Person {age: 18, name: \"张三\"} console.log(Person.hobby); //打游戏 %/accordion% 二、类继承 class Person{ constructor(name) { return this.name = name } say(){ return \"呵呵\" } } class Student extends Person{ constructor(name,age){ super(name)//继承父类的构造函数方法 this.age = age//student类自己独有的属性 } saying(){ return super.say()+\"哈哈\"//调用父类的原型方法 } } let s = new Student(\"小明\",18) console.log(s.saying())//呵呵哈哈 [!cogs] %accordion% 1️⃣😀 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { } let s = new Student() console.log(s); //Student {age:18, name: undefined} %/accordion% %accordion% 2️⃣😂 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { } let s = new Student(\"李四\") console.log(s); //Student {age:18, name: \"李四\"} %/accordion% %accordion% 3️⃣🤣 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { constructor(name) { super(name) //可以更改属性 } } let s = new Student(\"李四\") console.log(s); //Student {age:18, name: \"李四\"} %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 23:33:15 "},"phase03.html":{"url":"phase03.html","title":"Phase III","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"phase04.html":{"url":"phase04.html","title":"Phase IV","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"testing.html":{"url":"testing.html","title":"Testing","keywords":"","body":"Welcome to my world Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"weekly.html":{"url":"weekly.html","title":"Weekly","keywords":"","body":" Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试01.html":{"url":"每周测试01.html","title":"每周测试01","keywords":"","body":" 1、meta标签用来做什么的 2、使用弹性布局进行水平和垂直居中 3、行内元素、块级元素、行内块级元素有什么区别？ 4、讲述下相对定位，绝对定位，固定定位的区别 5、写出浏览器的内核有哪些 6、说明CSS选择器的权重，以及其显示优先顺序 7、使用内行块级实现元素的水平和垂直居中 8、使用定位进行水平和垂直居中 9、什么时候会出现浮动塌陷？如何解决浮动塌陷？ 10、什么时候会出现边距塌陷？如何解决边距塌陷？ 每周小测试01 1、meta标签用来做什么的 meta标签是HTML语言head区域的一个辅助性标签,常用于定义页面的说明,关键字,最后修改的日期和其他的元数据。 2、使用弹性布局进行水平和垂直居中 display:flex; justify-content; align-items:center; 3、行内元素、块级元素、行内块级元素有什么区别？ 1） 块标签：独自占领一行、可以进行宽高的数值的设定； 2） 行标签：在一行内显示、不可以进行宽高的数值设定； 3） 行内块标签：能和其他元素待在一行，能设置宽高； 4、讲述下相对定位，绝对定位，固定定位的区别 相对定位 position: relative; 相对于自己定位。 绝对定位 position: absolute; 相对于有相对定位的父级元素进行定位，没有的时候就相对于body。 固定定位 position: fixed; 相对于浏览器定位。 5、写出浏览器的内核有哪些 浏览器内核 谷歌的chrome浏览器：旧 webkit 新 blink 苹果的safari浏览器：webkit 火狐的firefox浏览器：moz 欧朋浏览器： o 微软的ie浏览器： ms 微软的edge浏览器 Chromium 6、说明CSS选择器的权重，以及其显示优先顺序 css优先级（权重） 作用范围越小，权重越高。 同样的作用范围，后面的样式覆盖前面的样式。 7、使用内行块级实现元素的水平和垂直居中 text-align: center; //文本的水平居中 vertical-align: middle;//垂直居中 8、使用定位进行水平和垂直居中 div{ position:relative; } p{ position:absolute; width:100px; height:100px; left:50%; top:50%; margin-left:-50px; //这两行代码也可以替换成 margin-top:-50px; //transform:translate(-50%,-50%); } 9、什么时候会出现浮动塌陷？如何解决浮动塌陷？ .clearFix::after{ content: \"\";/*内容为空*/ visibility: hidden;/*隐藏*/ height: 0;/*高度为0*/ display: block;/*转位块级元素*/ clear: both;/*清除浮动*/ } 10、什么时候会出现边距塌陷？如何解决边距塌陷？ 在父级元素添加 overflow:hidden; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试02.html":{"url":"每周测试02.html","title":"每周测试02","keywords":"","body":" 函数闭包特性 数组里的变异方法 数组的操作交并补差 js里的数据类型 css样式 HTML里的元素区别 css样式 字符串 日期对象 字符串-数组 每周小测试 函数闭包特性 1、什么是闭包？用代码实现一个闭包 //当一个函数可以访问另外一个函数的作用域的时候，这个函数就被称为闭包 function fn(){ var a = 1 return function(){ console.log(a) } } var f = fn() f() 数组里的变异方法 2、写出数组的变异方法有哪些 删除最后一个 pop 添加最后一个 push 删除第一个 shift 添加第一个 unshift 所有都可以使用 splice 数组的操作交并补差 3、计算出以下数组的并集。let arr = [1,2,3,4,5] arr2 = [2,4,6,8] let arr = [1, 2, 3, 4, 5]; let arr2 = [2, 4, 6, 8]; var arr3 = arr.concat(arr2) console.log([...new Set(arr3)]); js里的数据类型 4、请写出js的数据类型有哪几种 数字 number; 字符串 string; 布尔值 boolean; 空值 null; 未定义 undefined; 唯一值 symbol; 对象 object; css样式 5、使用弹性布局进行水平和垂直居中 display: flex; align-items: center; justify-content: center; HTML里的元素区别 6、行内元素、块级元素、行内块级元素有什么区别？ 行内元素：不会自动换行，不可以设置宽高 块级元素：会自动换行，可以设置宽高 行内块级元素：不会自动换行，可以设置宽高 css样式 7、相对定位，绝对定位，固定定位有什么区别 相对定位是相对于自己定位 绝对定位是相对于有相对定位的父级元素进行定位，没有时就相对于body 固定定位是相对于浏览器进行定位 字符串 8、如何把字符串转换成数组？ var arr = \"hello world\" consloe.log(arr.split(\"\")) 日期对象 9、格式化当前日期，yyyy-mm-dd var str = \"2021-12-17\"; function fn(str,sign = \"-\") { var arr = str.split(\"-\"); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year,month,date)); } fn(str) 字符串-数组 10、把字符串hello world转化成反序写法(dlrow olleh) var str = \"hello world\" console.log(str.split(\"\").reverse().join(\"\")); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试03.html":{"url":"每周测试03.html","title":"每周测试03","keywords":"","body":" 1、使用正则匹配HH: mm(24小时制) 2、使用正则匹配yyyy - mm - dd 3、下列字符串中，出现次数最多的字母是哪个？ 4、什么是事件委托？有什么作用？ 5、计算出以下数组的差集。 6、计算出 7、事件传播有哪几个阶段？ 8、json字符串和json对象如何转换？ 9、格式化当前日期，yyyy - mm - dd 10、currentTarget和target有什么区别？ 11、请写出web浏览器缓存机制有哪几种？分别有什么区别 12、计算出以下数组的补集。 13、使用setTimeout实现10至1的打印，每次减1，到1的时候停止打印 14、边距塌陷如何解决 15、如何阻止事件的默认行为 每周测试 1、使用正则匹配HH: mm(24小时制) var str =\"22:00\"; var reg =/^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true 2、使用正则匹配yyyy - mm - dd var reg = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; console.log(reg.test(\"2021-12-22\"));//true 3、下列字符串中，出现次数最多的字母是哪个？ 以及出现次数。var str = \"sjdklfjslwersdlfjsklf\" var str = \"sjdklfjslwersdlfjsklf\"; var obj = {}; var arr = str.split(\"\"); arr.forEach((item) => { if (obj[item]) { obj[item]++; } else { obj[item] = 1; } }); console.log(obj); var arr2 = []; for (key in obj) { arr2.push(obj[key]); } var max = Math.max(...arr2); for (key in obj) { if (obj[key] === max) { console.log(\"出现最多的字母是\" + key + \"出现次数是\" + obj[key]); } } //出现最多的字母是s出现次数是4 和 出现最多的字母是l出现次数是4 4、什么是事件委托？有什么作用？ //减少代码执行优化资源,在目标集合元素的父级元素添加事件， //点击目标集合元素时，因为事件冒泡的作用实现事件委托 5、计算出以下数组的差集。 let arr = [1, 2, 3, 4, 5] arr2 = [2, 4, 6, 8] var arr = [1, 2, 3, 4, 5] var arr2 = [2, 4, 6, 8] var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }) console.log(newArr);//[1, 3, 5] 6、计算出 1 + 2 + 3 + 4 +....+100=5050 var sum=0; for(var i=1; i 7、事件传播有哪几个阶段？ 1、事件冒泡 触发的元素往父级元素传播 2、事件派发发阶段 传递过程 3、事件捕获 父级元素传播到触发的子级元素上（低版本ie） 8、json字符串和json对象如何转换？ var json = { name: \"小白\", age: 18 }; var str = JSON.stringify(json);//json转字符串 var j =JSON.parse(str)//字符串转json console.log(j); 9、格式化当前日期，yyyy - mm - dd var str = \"2021-12-24\"; function fn(str, sign = \"-\") { var arr = str.split(\"-\"); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year, month, date)); } fn(str) 10、currentTarget和target有什么区别？ currentTarget：放定该事件的元素 target：触发了事件的元素 11、请写出web浏览器缓存机制有哪几种？分别有什么区别 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage; 本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage; 本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 12、计算出以下数组的补集。 let arr = [1,2,3,4,5] arr2 = [2,4,6,8] var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 4, 6, 8]; var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }); var newArr2 = arr2.filter(function (item) { return arr.indexOf(item) === -1; }); console.log(newArr.concat(newArr2)); //[1, 3, 5, 6, 8] 13、使用setTimeout实现10至1的打印，每次减1，到1的时候停止打印 var i = 10; function fn() { setTimeout(() => { console.log(i--); if (i > 0) { fn(); } }, 1000); } fn(); 14、边距塌陷如何解决 在父级元素添加 overflow: hidden; 15、如何阻止事件的默认行为 e.preventDefault(); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试04.html":{"url":"每周测试04.html","title":"每周测试04","keywords":"","body":" 1、js中call、 apply、 bind有什么区别? 2、解释浅克隆与深克隆的区别，并列举出实现方法 3、请写出http请求报文的请求行、请求头、请求体分别有什么作用 4、使用axios实现以下接口的并发请求 5、js中的堆和栈是什么？有什么区别？ 6、面向对象的特点有什么？ 7、请写出ajax的流程以及相应的代码 8、请说出防抖函数与节流函数的区别，并分别用代码表示 节流： 防抖： 9、实现一个自定义filter方法 10、请写出以下代码的答案，并描述为什么 每周测试04 1、js中call、 apply、 bind有什么区别? [success] call、 apply、 bind call和apply是返回值，bind是返回函数 call和bind是选项式参数、apply是数组参数 2、解释浅克隆与深克隆的区别，并列举出实现方法 [success] 浅与深 浅克隆：只克隆对象的第一层属性 深克隆：克隆对象的所有层级的属性 //浅拷贝： Object.assign({}, {name: '小明'}) //深拷贝： function deepClone(obj) { var x = {} for (key in obj) { if (typeof obj[key] === 'object') { x[key] = deepClone(obj[key]) }else { // x[key] = obj[key] x = Object.assign(x, obj) } } return x } 3、请写出http请求报文的请求行、请求头、请求体分别有什么作用 [success] 请求 请求行：请求地址、请求类型、状态代码 请求头：请求文本类型、token密钥 请求体：发送的参数 4、使用axios实现以下接口的并发请求 http://vt.ossjk.com/goods/getIndexInfo（get、无参数） http://vt.ossjk.com/goods/getCategoryList（get、无参数） function getIndexInfo (){ return axios.get('http://vt.ossjk.com/goods/getIndexInfo') } function getCategoryList (){ return axios.get('http://vt.ossjk.com/goods/getCategoryList') } axios.all(([getIndexInfo(), getCategoryList()])) .then(axios.spread(function(res1, res2){ console.log(res1.data); console.log(res2.data); })) 5、js中的堆和栈是什么？有什么区别？ [success] 堆和栈 栈是直接赋值数据：速度快 堆是赋值引用地址：速度慢 6、面向对象的特点有什么？ [success] 特点 1、封装 2、继承 3、多态 7、请写出ajax的流程以及相应的代码 var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest() } else { xhr = new ActiveXObject('Microsoft.XMLHTTP') } xhr.open('GET','http://192.168.1.217:8080/getList') xhr.send() xhr.onreadystatechange = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.response); } } var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest() } else { xhr = new ActiveXObject('Microsoft.XMLHTTP') } xhr.open('POST','http://192.168.1.217:8080/getCountry') xhr.setRequestHeader('content-type', 'application/json') var data = { \"id\": '001' } xhr.send(JSON.stringify(data)) xhr.onreadystatechange = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } } 8、请说出防抖函数与节流函数的区别，并分别用代码表示 [success] 防抖与节流 节流：在某段时间内，不管触发了多少次回调，只认第一次触发，无视后面次数产生的触发，并在计时结束时给予响应。 防抖： 在某段时间内，每次触发都会重新计时，直到最后一次触发超过了限定的时间 节流： var div = document.querySelector(\"div\"); function throttle(fn, time) { //节流函数 var last = 0; return function () { var now = new Date().getTime(); if (now - last >= time) { last = now; fn.apply(this, arguments); } }; } var clickHandler = throttle(function () { //具体逻辑 console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; 防抖： 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer var endTime = 0 return function () { var nowTime = +new Date() if (nowTime - endTime 9、实现一个自定义filter方法 Array.prototype.myFilter = function (fn) { var arr = this var newArr = [] for (var i = 0; i 10、请写出以下代码的答案，并描述为什么 var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = function(){ console.log(this.name) } a.call(this) } } } obj.obj2.fn() 小绿，输出语句所在的函数本来是window上的函数，直接执行a()会输出小明， 使用a.call(this)后，改变了函数this指向，现在this指向obj2，即输出obj2.name，小绿 [success] 答案 小绿 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "}}